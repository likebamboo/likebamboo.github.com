<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="请输入密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            记住密码
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="确定" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "密码错误",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eca974a60210d3cb70a720cb4637ae6213f7364c472880eef5d5a4b7f2404ac4fd6e131a90b6f6f1205392dd0d5936167f77bcea00a92ba6a59cd652a1ad2321f566621fe4b62ca08a15f505ac431997598bd940f373dbb894d9d099980fcadc582a10d2b26495ef8c06e7b0a99862921b0451e9a4d96f5e60d4b67054251ff1d3021bdd1be59c4e88d2f2bbc8895ec645582d203cfc65b9ab7d04e0b66c22902209827f77f1e8b2eaf5294309c421e3f4e2763042b137ed21f5c75602280fe214e30406ff372b28a0dc99a633e1609302b9f97eb4a705a7977c08baa0b814354acccf11cea1103be04a2f0d1f41bc74aff08cc4a31ef69ae31dbc8709886a361537b5936ee29dc6bc16078a1e4e77e9d039c7e23e75a38e0cc213a9d1b1d5930abf313326ebf8ed3f593febeb24cdda9407fabe86dfb8f3611f389c9aa24d15e146f1da1c6f9ae29076305fecdb9f09a79808725de10893dee81e89b10d0ed2c075bfbf877f3970bd4d1649f53b8bea6bb39a74451210e9fce11b9cb7c8a0173a70d976880ba5a326c23429358165972c4c17ad86bb9bfa521297c5d68f7544af0b683eacd747c3751876f4a4ac8cadb9c16158cb13c9faca7bf33ed1619c51c6a77995eca312aa08bba497216a5c983eda5fa0b362c0273670d590bf41ad2ddaab687d862e9e33d938d28051d6d6189ada1002922d48c003cac1afc390f49b910b27f9c31473bc6bfd2af250b092375e0b73cf8c1cbf366f5322a7b854a2a066510fcfb13ac07ca02f59cbe87aa44b8090249688817b2b32d29d1d7de058bc26d4953c1d7bf9d6cb154b4ee6ff53522df0ba8e66d9c907fbdf8c8c74f7b886f7c614553d5c0ff64472c21aaa92a55e92670f0bbc09f00845a05f59f58a83fb7ff0a88c3611e28f498f321eba8db1bba58b03e9d145492a25ffecfa69a4c1c1d6fe71c2ae8ff55ef430cbc2bf238bdd663efc442cd952509be4eb29caf4dbef7c2e52161efc0252cd295cacc121736964ecae89b04f8c4a0389c38f21431e805ed6b6f64661a2cc4231a79235ad3e51ee6da308e8f8aff40e8d5ac9181c272f5bd7a953962191f7084167909f7be0a3a99d11ed4d814d8334c3977d054fb2e422c42b6a4409ed7fe38e3cb36231b2f35c4ddd5f78f59e49554e952f22b954c5a47a92912e90b48dc379bd94ea71982bc99cee4135f4acc5b33e09c8341f4c7575cf8c53f7460f940acff2c956fe36dc601f174612443dfba1610db9334501ab593b6923b1280bb58723e16864e18194069cddd72e5849fbd4de322386e997e76218d705a39a65c954919b0e5f6f40e138d7484125abab27a50c31e0a9f52fb389753d2ca65490eb7d155e8b2de075eacfc57a9d1f9971fcd6ec38060a9e5e4cda438f967aa95e24ca47c9ae24a52e6f4a7f406a8c35fc06285b659b588b3d9031e726b7e182375a6fc7954f0437c40793cb411df7b38750ad027d6818c6e17130237451a0ee6f0bc1f29ae0cc9a0c6b852101c9226476e30c25bfcc87280dc59bd03db80faa759084631b29c3197db01573e63715461ba7e7c9074d50d5278b7771988d27137746e2e0285d4605ddf03e564a60917e3238e4f93fe12e01293f084750749e2f1d2d9b69e699057ca690196239487b6f620c6392ae5106fabbc7cbc2e0bcd9c05cb5f1bd68cf48c9900cbeecfaed2f6f63786bfdf3625db32fdbfdbeec2f1795f5acf3bf9d98bc112c3865008d9872e3be851fd069acfea41d76f56779c06fbea5c542ea51bf16843a619b0cdc5ec0a1390fc2656b9d2476c4c07cd2c51756dd8233e1beefba84134caaa27a9485dd0ba034385d8a7e2189517f5575e7d109919352a3d1ab6b7303867770b4a231e94ee93d2eaf07fb2402dfbe6f5a80c482457b3afdea7bdb915bcaee01e777406136ebba8d9e55d041e7dcc65708ec2cde85d13bc5bf5d3a4a32c1cdfb4e1a33e7aa0dbd31204752f76506171b1b466f213e017dcc25a8367cbbb2b934625387c9145d281d1a46993a3be3fc511051b0d3ff0e6d8885665712f88518b94dba77d173a14b48395bc023f72dca6d0c0f338cecf5de449be4adb315d7b47ecea7b7f669f48a6316000683b22f131b59339a1f2674d9a382d8b53c3f2da519964d55c07d5fc4d862f452c1248b025f61b9f26e472bce42b075cc96ba9b386d63ba8c75e882b8b12c4e6d51970bbe4abe0b6aa4d323d89ea653e8224f367ad15a03008cc66d3a5e7ed95f27d98d2d1e9f7ce5998dc4dfeb0496a13b11e2a2501ae4f7e72f15be3fd4169e8c787dd6316db6002625c10372501b0b83b0f62aabfed9628e4035ccd2154afd012fcbfdb10685ef83e34c942eecc9ae33042cabe9f05e5c4b4c98a7ad1c28b2cbc35d03bcedbb2e0e6ebb0e79ddb485e64ca1499de8459ba9fe03285c49c77f5e1000601eb822b6254be4d11599a9ebfbd5bd528f6342f6000674e483c34ea46b8d075a2fd49a30d64bad0adb7fb8f10ad2381bb3ac7dc2c47a23bb8af3f8f8600be08263738f796f80ce62ef7355fd7f280c7b9ab7bc1da09d948141adc09cd6907f325a9aadce7067d4b594c2dab9669b9b9db3ac24ea5e048bc0c6ea9ec6a2e51d0efd2a19320b0a33b8685b33dc6c81fc041f42ab7911ffeea4ffbe7f81594a1769732e069506e093f84c219e2cc513154cc014a0c3b5a599774a40ffa651c6d34c9c4ba53de687524947e3d9ef5c95d6fbc1074cc2a00520e00cb41257874fcb68f5a9bc59ce8cbc3505026f74113bcffc149aa33945ab01386ff614eb990e9180ed675a9233943b9c5dc172b26b1fe09747e6fb5fa71025a4bfd22e21e3ccd103fae0c1ad39024baf4fe2e4fef7218e2007f2b0c5a49727d14a503474b8a223d2c41846868c1f8ce694332b0fbf92c14c0ed446288ed6f3955ad3c8b4fc0c6af1346ed53933b14f647eda7410b179fda0876eb47683b89d416ddb5189f9eb3b30a9ef0e236279f7b647f9ea21e940d079204f4bde0a18e22232f43a026f0911dbc741a598c069074af364533143a4966a0e76cdd02648ee81cc74c59c3f8115c5a2c5dfacd5fbf4366426702875ffd878a82ffe22588df48fac310a659c5b0046140fa63b2326bb153838cb687860b758abffb05cb97cfd2e9eca60ec056610d0d4619eab3dea5796064e006e7b14498e12ffb5b2551ed96523f134f5a2831483e6a5e0c0236d9a1b7b87cde45cf678c251553a18465719582022879f55c7c6c02874125ea377270fc51f8429947a1ccd7039af63171b47aa86601f54cbb0b6d6e316b164721295b8e366dbb45ca2a23e85fc3c21569e1b18a5c7d15df18e49cca1d202be27a80f62345d76f1a1b0075ef31f648c59a4acb94f885ebb054e7e08fad5b254a371f04450a64d534da126d003251b6d94dca51afd3d764ac2969ec23d53267b0bb0d85a5c66fc7d9e22f8e663c846b50a68dcfc4361fc55b43260fe349eee6b7b91a444fecaa154672d7fcbe15ca76bcbbc3120f83dd77b11c5dfad886ea1f6e54b4223471252057705ce8f0690467e70158bd86c726ca97f6cd6a7628ba47a6a3269562ea308c8b9c60778127c54dd605322483c723458475ef7a4429ef1676fc7912742a3028d13c158b50ebcd7a34781ccde7aae5650881ee6319d14ed1252f040455233452647945a8f4b1bb692dd5e0bbd2ba6a2059067d5314563d7c6f370078212cd72fc5e0753061cf528edf21adda5b480d2463fb91b0549be0410b1e95859ad380dade0184a28f706ddbcf8b7befa5ea9d72baad809d9047b6e3dacf52a89ef1bca4adb129cc8d38fe2fb9f34a92f02d654bc40952e8fc08d979de934699ddeb96fbfd2c68739efb9430199c4479a45d53aed0466b559b56065b5a987cad2d5e70463b04028658fb8e70d9cd6de34db27ea08db99cd9729ad53731d871dcc5fdf0d788d6f22c14c14033a529d2f1545a615a4d3b15a750061b67c03d075fff57bb39a581093c44440d7e2216af86164e8beefc9af393d9887232a3ab9ce53a157e62586f3d96b5058a087728e399a95304077d0427d700c77466ab394af9537077357d16541ce07260891d94e10a2cb8a4b6d85194e7ea12f116088d97178a9658842efd609818a129e4c269ad28c365f7675bee682a0b725957a9ee67425afde20c539b389a814aa3c7e55b079446f95220da03b457efae6d6d930ab1a7e9e721a9a6200866bafc24aaaa306eedafe86478bdf42238f7f317e96e85b043aea80b7070566c589fac2c9f8c705a4d0e3e50d193e0dc38f0e7145994b8c479c0c1207d63df8534b7fc5538bf13a7f3d75371ff801515f423325cf25238b6343a959839ab6e41bb75dcaa04ef21dae82e84854e0b6eee7ea98241f2059a979b9aa6334dae7c83824f119873b6961f89d2ea262bb053d3df2ffc4429bceeba7fedd3c57c997716b0d846ce6ea4df2515b15e3411b379a357fde8457f341e325b8dc393ae6fbbeba111d57ad72d9779e324fe4c6c309c1e14f480b2a8fdab89a05fe363039e87dd9a9621c4e5843d682a6ef1986667aeaeb330f1359e15a3f7784735738bdfffd0240d74e24c64b82909edc986e0ed3acfec672a1186afe7463b7ecc8ecb8d2392986e3314551e74acdca36be041691dcd49dac1a041d78ad1b0aab006341898affe1f521568d7b4459bee33e69fb0b6eebf14f0af116c6c5b7258ab3a7a40cbc09793652cead38bb76eb43ae53e5ac19e54216d3a8dc47b9a59cbd6824667442d0674d8cfa49347d21dc272109886157969ecfd26a1f0d3754e6f574d0f1ce2c46505265d6c7156847597416a2049cf38dcf9c88e1e381dd0f056e7615c6fa0e2183480d644b2eb1c6803ef7ee940e4258d6c8efccab21ad194d9190bc3a74bb76893045448b361fd465af8d6df1b89178085511f2d5f2609848e2e679acbe596569771f4162acaebd099762a783d250d4cf8da2774ee5d7ba3d1645417ce9ea726ce5e65c40f23dab5c3e860630c55cacd234968ca44a9478869aaf168e689a2a691557113d4f586b2def99fa653fc205b408c11bb979ff6027778163d0eabf79af1a0844bf5c966f2172ecadc633816955568ca5068fddd98476509d83f61fff437c0f3192b95c610dafee3c35e79c1c3ad140469771b48ef7702175c2adc06e5cb5aa5fd1fc2f289c92199dcf6cb1a0392843cbf5154b2a581ff9e67fcbdab102e8d9825cd0a070735ab3a7a5c7e054e27d128307d133b10e07c51e402907ae044986a384d4b0ee2c5670d2e1acf69db1e32f15bb9cd60e672a945a2c665e0219fd43645cda0dd7940696938b3eb624a2366a4d70f50ab373fd0fd4d25e5dbfc3d594ec4092ff7e85735298e01c140033565ba5cbd88e2e17acbee802714a124228211827862960039c9e2a30a674a96c8522c92213d1050a10ff555a3aa3eddecf71955fa867ebfed10d390d8423f19a3e458b25300421671a36e9bb3d0f6cb52a164856de4d190a7166398206e1f283d32a3e05ed6b4fb95d6ff992479600f29bdd823af82818921935662affa9e79c5f8c83f666153f3e47f5b4472421784e7110f85b81b223bfd6914be5697f6b631651051bab15fedd54d498d590e9f38182852065a837425214abe0b75663d421572d5abd95e259b4626a442d912187df2819b6c88735281e2efbce6314862831f90554236d28d31bdf97ce17dd7bc6e02fbc18a9cf7dd4aa50f0a26c2a810fa9c25bfdb384fd9794cfc5e3bf7d07a75e92755b9c6f3a0145fcf2a8c2c8f969ec47b5c21f7e0e9947cc3340f5e52f383426d1650677f031730e942757eb216ee683a861abb74243493bbc8380c896b6cf60a972e1ea4487d022e60df812d752567058d5ce5c07b3635f54287e2043af3b21a75553af8e721a2eedc4d21a13b61387c6e504abd77c3a9ca70acc5bbf25fd99932932182f8061e7fa335d6ce18efa7c9504fe6631b98d846880b177f189082162edf1f711ab47e526efa4ef4508a7a90c4eaa4111f999b1d421826e266215eb32148a6727a14c81a570f98a75479f6c9ee18547966ba95cd9a8cf58fd7403f3205e23c494b45db1fd4ce48218bd04004bf1049cb6e8ba674e0ae0004add7bf102a51ccd093490afa5e85b49ca16bc9f656bfc7da53e66943676fe510bbc558b353936b21bfde45dc790c7f436acbf7922995ceca8eb74836af9db0fe2dea6e010921047a19f62015344235d0faaac72a66413c2010c895e660470388ea8c5df295d1db5cfaae87a3776d7b51ab3e85e480470309df1e2c4c96c148972401868413f0a027fdf8a93f2c2aace35266b864a2458fa7bdbb12ef541ca9d6c2bc1281573f30b658ffdcc7e599bc481dc578c769f12f51d291b7434de43fa5e64531fb9dc8d86abf599b1f5d1c2a5605774f45632f8561deda23fcb71cc978015c5b2a53cd2875f7f055bba47c2ab0fbcad14b318498ffd4f431641d0017997a941de90ac0010402ee6615c8a4ea66ae7148d02af8dc3ddd59cc30d36925c1ee5430f1fcd6b8cc50edceae2952a03cc4ef04364ff114d8bf827061a37d82e17e18841811abe18a0d239c6bffcd6e5213a254e4d71d04558ccf88cd3978316e5cd167a97ea04362f35195ba366019e7fd4dc55e50bfa4ac3e61d966f38a3ff1bfc1208175f236a7aa3b66d9400e290726d258bf8778fba47deefe279eb9ec3fc35cf39f52815ed6625bf74e96a6386d99d8039c92f78376e3d452d9785c07aa72c48f5335b4432e88153b51455303f0a1d0d580df8548af861331e9859f58d6756113beff3ca31b1290a5af1fd4527710cea09fd4443b1f8f3322a57309b5ec1d385af7b942f18a02ed0dbd6d339b3da685d9b2f47b000f812a5bd94fbb0b15d90eb0884d8d4c782f1798dbd1851fd5284f224a52c05716d7e3af888c68dd4da3fb719a111b173864ef61a3fd08104fcb2b5c3126a27faed4c9b38f47741f46ff83f0d773835580117465b3eb118b1fe391f7510c3044ea829318ae2c4a8d0a76881622a2f05ff2e33dc6f1b669f681d715dec3e6ab0f2e6b68043098aabf2fde282a2981b7f135db9e3f2870b6a51ec234e4b1d6cbc0e37fcd4c71b6753b5f23c3b163dca6f2bd197f45d285c05a827061ce7bc9f612831590a0402e24dd0015f1faeec6dd3e98fa53e1ea9fafebc527c2c1f4be97266ae7eaeb605954ebfed01581a37a7785f7238380529b89624b904a04da680377d34378748227536c9d12486d3430182222c32519f5ce0a78ecdde9d9b485a9e8955aa72a9c7bacc930b892c1a47a2ab3b8dbe52db05bfe6c64373d4a7a024c6b536530e87696c39ce0ed267c6ada879da91b2126409d4b7a0dfd43831c76271af611da9e3af9a0784596d62a15aa7520d45219438cd1b99a097e04d832b2d857c236b81e033bf6b723ce7112febdc215f60fa81a9e46e8965e10e8fedd1590c8e56a5aa10e71b531f505d7c7af6bdf41cdbdb3a3c850554e40c6550440b4963695c220528b78148aeb922d4b4e7ae8f6a2c4a49b77201819e469834cb7a7e95383494bf838c6523f7544ff71b583c60494fcdcb98b406b0810ce807f17e12dd14447ccb75e0f9867a075084b58ed19aaf8476509f217a9a2f8239a87be38eb3503ed2f0b7652a4aa042e7179262394bec204842c6c451130ae006f5d9142ed022025681ea4cb868cebaee97f63dfabcfffe37d1f4f1b9480257a5599a73fa01b56053a110a9f7e9dd599a55691104f132573765657df1b42e028e089104b62ce412bb0c7cbf327437cc57321aa9621eb16ce1506193c1b73eac41a07b16c1ab8632c7503929c764453181322bd1c3d8353d0e680241f75e1d6eb79cb172f4105b059eb35e6626d2929b64048cca764b43e8833cedecadf201e1b7b4e7b4647c819c7d5c8bcd5f3e19cdb6b19886a76ead65253318ecf0c6365c3c3b1a2cbf577393748f37b4d0a0fbf57765e34ab1ac0fbb703ec73b6db13914d8bea8469f41c04708808f0fcfc625aadc009192650c6d208d1214bb9f6abee36597763dc8f547a1a9f60dbd33e89974046050473edcae25af494d5bceb5904cb3e0e6666dbefeadd2804d2f2fa1ddb7fe853ee126a3d6edeaf9ca89c65ed9b204834707560ad4a7220d4368a81e6f8956039e57b3283e795823051788e975953d1b3e386935b1ce0b2fed0670606c32b3b24a320fc857c7e445a199424a32e44b1c730a1da483bb3e0c49730216ee10a971fd50124a6cda59c5912f2ea797c6c08a437719b6c6c551f1c37cd2aa261c591514761778d015da1465520bc484993b06341de8993bf209071e421aa2af58d96e5cc0045981c8c48ac5f7178ac8aa662f2ddc32af3429f2ef43097652fc001798a32f4f415c59f8b59230d4fd95f76cf4a2e96948d162cb4efeea18f6feeb3151e0f56b43a925d56a35eeb3ac13624357b74cdec74e61efa9a40aad9bd3be5e28dffd4c595dbe8a643e9df2c2412d6c3638bf7f89c498156e8375dd4b6bf5e375f16c869b83be222d7fda7c27ef3cd7bdaf3e503c2614c8c9b9bfa4f666c6cccb7513ed3e1d2154bdd747dc3757032f82b4c6f6d9c6558f2e37193c1ede7a88133186097f6744404173d7a22d8c5e25a4a6bb9fdb4c956ddddfcfe29f41190642030d2f18edecf20a0d09cdaa9c4bbd3e837dbe53ae36599288a2e0022993881013856762bc0304168b23b966c3e90bf64ce4dcd56e73604b1287790f9d4fb75b407cc552aa17e2c6fe879565dad1fbe537fa2aabfa8d48dad27fd339d0810825bd4f24dca636c6c0a1d116f701b0e446554396350cff31a16f95476a32369a3b8912e5d670d0886dea8425e273f694e4a0c9869d3694f906646c0f1d8387d776e5a5149f23e47c9ab64ae23800b9d941876c5176f222b71b86d93d54f15e5f11f505b98808a5498b1560114967783c9aba08e7be131e6839239297de10f522020e78dd6b92432fbf13fddb02547636c87fb30cfdb54a26f39172ec6eeb5818694c1c8521d29f63eb335593e80bdf75140b4062bf2c85fc2601c8626f8a7103b65968631553f5d90edd992f9778f169ed02faae445707e99bd8b56886e5803e22dce90d33c1502137883f2a3201768658b3b930acda9ab0fcff496eec8f8836140594b96a98ab8c2c54670908e28e986a2bf6aaffab1ef09b368be14253f313e3eaf250e5bdd8e891b5f1e76c104850345d90878cbe5b73a499e2dea75f6022d85922ebf9c75e11a1ae6b7939dde646388ee0af84160e34cbb6e672af88cbe0ae30757ecd0008234ff4f9d78013bf28fc023149cdd47450ec7be735c828e74d62fab75ac3eb1a2505fef215576f4c1b6fae6d39e5519ec5b9e2ebbcc381dcc9d3bbe6692924640b24ac5395afc390884fa591de68293372836d66aa94dfa43318bfd5da0c821acbad94d1f24f3cbb67ca6903bb25bc13eede092799dc3b90f7475594074a7ab9712b1aea5910ef55fbbbda49c1821c881dcba9c529eb51033e6f95eeed6f03534048338bcc91e891e1b7559781e08260ccac60e69e7b10ebe095e03bc851409dad3d4edbd5ce071b8afe2e88e298f5ab71df5445a22b16f61ee6a287cbd569fed77e4167539f035a31a0463aac4034fa132c5f2994f67fff8ed19f9a8442a7d887123e8a3a8318d7731dec07dcd50d231dcd0e82379251e1e1ae3258f602de002936b3513a26b7aa20b991eebc0b33e46d77a28212d34f1eac19d8c66b016ee32628243f7a08faeed81ee9f56850fc44ec9bf4b10031c6571f5d6e678775f81058a02956a8426d40db25af32f1d6e183df10fe8cf8c533aac1a0a995846e5bffb8227165c773fa1f436525c7cff7aaadc7b6276084603e4b0dd7fe0a8635890657a5d31c4583d481bdf4904f11e82c1be9cdaf91de347027d383a893ee26a6e475aba96dd3b8da2d1c9c09edc3a29a857f16abcdba0963ff08d2e3f5d2054a71d2da378f2dd1b83b35da5e3543bb8d2e89983f92d2f59349b62cee2fb3f2dd2b1e423e84ead55f26fed01749b4f2969889fcfcdd22d5bcc0a0972ae475cf72c4dd57b6796e0418a2edc156d25c1acc8ce4695726f5debe8cfbd51118d6088cdcd7b3bee8163124f0e0677383380904a40b2842309a06b9a73eef262f028596dfd00ec709234add169f5c884d1154b87581c5b2f3d36986542f8cd1b2aab53620bb19ad9565c679e4eac93abf246e8c74de74190a27062bfcc0a078deebf12a015ba7306ecd08ebfc8aae14b4704cb67763ef255a754b5ad41261b389f4149e3ccbc0923bbc50bb64a52357de929275c7b24ece0c90e20490230af20588e5e0dad9e6297d0c0a7ac3e23f9e9d643172e1b96044ffd49ff3d02d15d4e8c56a864eac476954720dee509627e88326fb44dbc29db0f23d367355d6b555d9d3138efb942d3058a120aa84a804df426f1ed2474b954fcd830d8ce966628ee6c1e5f541e37d89ca1bd6e1b811826ea5b11e6cacd4ca33152c4cd4bfff25e5111dbb11cbc660c9cecc833a7bf3b1d6524e5d117ac72312d5d9749872ce884c4d6fb667abe1a7e902bdd4a2d755448b01de3939d2eaae6b5dc4c4ce0153fb85251be9c32a24e37e4fc350ce8075afe0952009150e88df2851acf03ea14223045676dc2a25f7814ebc6699b227caafd0da51bab803d3119e334fd1a3ca318e3b611a92b1ab63c7cc0cd29862717cfbf4e3153a8cb1626c383b06de6648e89488b9c2d2354abfb98e671904432710eabfed02807095b50f653e534f9103873fa35f5afb08108f0cd09cb43f6ca02379fff4890bd19601447615dc55a89d75e996e6c53588f32bd9eecedba732dfac5319fe0950ec35a4bfdf84311fdf2286aad56d9a7003e2d8148c37c6c79c23d8c66e31869bb5fd871ae1d1a238ee88c83894dabcfc438a23434d9b23cf9d33d90043b4713295e14881d5899b887f8dea6be6e7cf3dfb70e0691712524d8792b638482cf798cbac3791228789cc6168f10fb24c7d9d275ee7718403dff1d0e08bb9ec38c7cc174c054077b5c29b6bae71b411590978ba255467e95d6c0fd27867b91945adaa4aaaf65cacef0a9882cac2dad5c1171a12b8e1d45b33d3b75eccaab1ab1a2d3b8bd82acdff73406379f69174592f24d7f11c8036b1a9220c12983a70e31286256c2d3a86b5b24fee22ec1cb10175e36b04a652c54b5da746f2028fab98f872c15b5f09abcfd6decead6cb63aa38f5c906d6b25a332ed170061629b64fec9e82c032c5a9ed2ae12433059b4cd2a3e4812a0e7736f8662251c705eda3e6864837358277f10cff14a8da7bfb1bb7ebc4723d73fa66422755688d953564b9215d2bb27e231271ca8a857c24fe256f6c6b350a86ee2b2e7d7945c28f08b8bbe650cb5a085f1f50b2230ef8b87819715a2cb6118f8a1632d4cfe0edc11b88d42768e11ae6638cfd63a19b2288ee5a4033885489975761dc89d8e140b0e7c4544b0a089b2f526d27e3ef36b86ef88e6eb1a206c1b0d6092a4f35181e78d844e3b2c969ca09b911ca285f63fc0eafe547288f328f445c3fa6e95a7c94a2ecf27d099f3e3ef6800cbe973350e1ed1fa5b51031d05f759730a538e448a1dc934b061705d2e5d98a76a1ba07ccd559b856c220db6a578dd841a1a52e0dcabf01dc2d2e34733bec5842beddb20bfba14a4d39d6de63c868b3f98d9a3a3e7a2e564f40d1103393117362cc0964ce806fd11001f2b0a9ac03513dcd3c1b219bb172b9ed1b5bc2baaf945794b1f882f8d8a8aa12431d8f2ecfc0bf5076e0fe11610fae3fa7da1ee3e956b02b5087ea344ef88a8282788543666ff3e43fb80a534d307d42c17b98bcdb4fdd11815e1ed1aaac30603399fb59052f1e1ab88e6f863f7970930076258b19691af653b2de95bda5123e75ce210eb7b61d1e223623e45d02d57960865019e7a15ca785efbf1606b3d4eaefcd816361be45f15e30b87f5e680a81f509b6e9597df7271286643c6eb6d30cfab37f08e013dd210ee51f451324454094bab96d98c037e8dc2f43413dcbb84350676719b25dbed5ee5fde2c3ceeecae03d874dad68a2825cb5995bcfd785d5c657edce91bf4b8a8a79ce2f7b8d4963a8a1c3d68578030aa8a5458cdce6a3585592a7384feaaf820ebb794cbeff80dc5d2fb71bf99d9767a670f5593225264172d7b0f89af71820559c63da69b1a4194eb671132de81e2b2c87ba1188423d2a499bf85df7be65b984395c09449284fd0a1104498b8aca3aec02dbe0c65472a8091b8085f697553539e62e0a6ba960e34b4ab918bdc34f3e5cab24d2e38a124091a11e509dc33838e95e14262cb5933d4d72f742b48ac3216dfd19fcb85757cda29ff2159618ce034222f47a4b0dc53c287cbd7f5df22a1117624681fd3c026980774e6cb5d0e3504165e541ff8c7a5325b993c466e8559b6dd732d98a370ff0af5551e1c8008973cec24d15450a584bb0fe01b0adb634a78a20a851e19fdd4b8a97a9890ca7c85625a37f649efa50669ec572f3fd7f9ffa34484973e6f56f61ca7e00c8e94dbe2334f9b885b517f370abf6c5f9c07dce98c7bfb5e7e2b00a015c822acf1e3d8ecd7be073573b5671d40b4960f7c62f6834f39072d5aa4ccd2ea64cbae65071ddd204e04dc3c62b34607bf6a5f38b1064cb68745920717c305dd7eea004146249424294c21085ac941a83ffbf9bfc088b208f1eb563d7664afc5ef3e97e0b39b7c339dab9d346c63f256754c9e127ad36fa4a0cb06b18542277a3307310c778880a940dcdafdd26bbe7b3449c2cd4ef58751ea5e644d68da7cd94130a8de9d4456fc6590cd0b5c8637fc60b186483455e22e98705d1beb503d6e419484c0f8c140d3c6dba7e4137dee18182afc71c1cdd08b16ed6a733560126080f13a6cec7834caea5c0c1c5cb3b9021b5e1c92eab5838fe36c2afe9fdcd3a14cdb4c9abd5559b009e0aabb4acc0319babd126890ffcd9c2ce75ec988a9373cc400aabb60db06414cf1337d012bf52f0976c2a417eea227412a022e781bc69563bc009552284805321255c175b55f5ec91ad5b59245bc0ede1595ed7553a6a18d4ca02ee78d84c336fe5766f1b73d59b8322ca3ef6dbdfa04778ea5c91868513b0c82130f216b69609bc185817a1bdd6c2cbf0289b76ccf62f841b4265d3d957a800265191460688ee56908f3519b4626fd2a9022d2226e7114dd2b2bfaa50aa67e5f69ea0100ded811be0b57a397687534f2ba27c90876bd2b47cfdb9ac7c24d600293726b92b903502432f4418b98a46ca89a9fff3cae9a349b4836518986f9a0f43188d8462bb9a0b6fb7d1c98e82f65d1266a200e123ba9cd077355c871103fc9004d4e1a7777bff7f294761fa5874776d55cea891d404afc88e7b405a2fd68cd4198e65119bee4a1020cffc8a6bfd871e4add1eb2baf85061ea15d9353fdb8855d6cd1e99e69c0c3f471bc0a6f9a59e2f49b6b1ac03889438bc61844b6c47eab6d45c0a2b5dc91630cd4e5ed10949b1ff4d4f04ed30d4b45b106ae5bb87b6f107aebf77ed5fbf338814c2e2f262bafff08e21ef0020988de85b1aece7bd970c837bd9ab3072a48ac427e894273be212bafe5beb8d0bb0875585b9ad70176c2108b9e254484bc7297598ea8d9becb476a0ac2ef8e502426a01b065940e642a82cb849a97581f1de6cefa7116650af968ee4de922cf1924c1f6d076c83c1ac0bcd7d8d4e75a0ba875cde6b82db824c621eea20b3c6d83194f63845d7022d5b2540b04ac21f538341114225aaf26247c482f72d7bd035fb3552df967ef7327d9d50f09f2307d5266b09429a92a63452f965683e5bbfdd23fc7a1d0a5bc4073582d6306dcb1de5b6fa988964a13b7a498990f6621183a723b684869fdf3d30743fbf3834482934d8b3038564a79ee1ff5e1179cf8b1bab28d2666f00fdfa64c4c050213f96a9a944d153b6241609df4b7d83be370e878408bddff3f0d035c19661ef9b9d4fe3232dc82651ca424dc27820a58595f0228e614ce90f5b75c3cc0758be701fc54bdf54e838b5017fe63a5082233cf3c70a40ad9ead0c53934187ea0ba8cc08084e22092562d605d9ed6458fa827c42895f5a43f0c8b3f69bd260d8fe29aac13d68e047b4bf2b65a7a6db8fd48bc85228f42c6d68d50817cf25977c0bbe5bbfb769ad46fbdf4853a3c5b34c2f11cdbe580af814db198acd63532496b740e37a31b76b9b34f0ab59c1f58fe09d3252ca9e1bb67c54795d9fb4d557a26ee9b2aa5301f8a2d591fdd657ffaf32a1486b3b3e992e1492b038bd6ba0c7ee174e1eed6cb3e35e4ac524ab3baa06ad62c85e4f7d24ff1700b4ba069b92057d730f97002b4d4c136da330cc6b654f62b202ad8e54640c623ba8adfdfe6b6a0736f173bc59646ab1ac9ba0e5bc149a6e2b0a0cd9f3bd123c8e7c62ef2e0ce0089fd9da7644a41ee19142da89e2aa00fd68a41c674642004e1f9bc20208906ad8ef66c0b1a49697bd0832d13aa867715954eb75248259353e62a7e03c5b540debc68e1c3c3c8097525a4b7fa022a5082ef9601077cdfeb91fe2933884ec5afb53314c75367c957cb12bb8907598563e0229cd23482157d9dd78e4e2f7acf1147d36bc50f42f0aadbdcea2c4aa615f2fc19bd26a6a46a42aba90732e2322ab58e3bfa8271b6dc6fbbf1347c484ec5e13ba40d75f92e5e052dcfd895ce39a74e5d74dce26006950813c750e5409799d1c9a6510bec8c30d06e7014a5619d75837ba894f3e09cb40a33216ee26bbd0c82dd9e9ac8d1a3854f651c876b88b0aecb49629d215898902cfae9769a729625bbdebf84dbaa5e62b41b2804f2a7468a866bc0b50f3ed110e9d61acb961c4e26044fceb3f36bc3d889ca73719b6254b03c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"83d4111de476dcc67c24dd230c4d4d75"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
