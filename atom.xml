<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如竹的博客</title>
  
  <subtitle>诗意地生活</subtitle>
  <link href="https://www.likebamboo.com/atom.xml" rel="self"/>
  
  <link href="https://www.likebamboo.com/"/>
  <updated>2025-11-15T04:21:48.660Z</updated>
  <id>https://www.likebamboo.com/</id>
  
  <author>
    <name>如竹</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内存问题分析方法总结</title>
    <link href="https://www.likebamboo.com/2025/11/01/memory-analysis/"/>
    <id>https://www.likebamboo.com/2025/11/01/memory-analysis/</id>
    <published>2025-10-31T16:00:00.000Z</published>
    <updated>2025-11-15T04:21:48.660Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h3 id="了解-meminfo"><a href="#了解-meminfo" class="headerlink" title="了解 meminfo"></a>了解 meminfo</h3><p>遇到内存问题时，一般首先会用 <code>adb shell dumpsys meminfo -a [进程名/包名/进程pid]</code>命令输出某个应用某个时刻的整体内存值，或通过持续调用该命令并输出以观察内存的变化（类似于 AS Profiler 中 View Live Telemetry 那样）。一般<code>dumpsys meminfo</code>命令输出如下：</p><p><img src="/.com//dumpsys.png"><br>其中的关键指标说明：</p><table><thead><tr><th>字段名</th><th>说明</th></tr></thead><tbody><tr><td>Pss Total</td><td>实际按比例计算的物理内存使用量。任何独占的内存页直接计算它的PSS值，而和其它进程共享的页则按照共享的比例计算PSS值</td></tr><tr><td>Private dirty</td><td>仅该进程独占且已修改的页。代表真正独占且无法被共享的物理内存</td></tr><tr><td>Private clean</td><td>仅该进程映射、但尚未写入的页（可被释放或重映射）</td></tr><tr><td>SwapPss dirty</td><td>表示这部分物理内存已被换出（swap out），此字段仅在设备启用 zram&#x2F;swap 时有效</td></tr><tr><td>Rss total</td><td>实际驻留物理内存的页总量（包含共享）。不做分摊，比 PSS 更大</td></tr><tr><td>Heap size</td><td>逻辑堆容量（最大总共可分配空间）</td></tr><tr><td>Heap alloc</td><td>当前堆中已分配（使用）的空间</td></tr><tr><td>Heap free</td><td>堆中总的剩余空间</td></tr></tbody></table><p>各区域说明：</p><table><thead><tr><th>分类名</th><th>含义</th><th>说明主要用途 &#x2F; 常见问题方向</th></tr></thead><tbody><tr><td>Native Heap</td><td>C&#x2F;C++ 层堆内存</td><td>使用 malloc&#x2F;new&#x2F;calloc 等分配的内存</td></tr><tr><td>Dalvik Heap</td><td>Java 虚拟机堆（由 ART &#x2F; Dalvik 管理）</td><td>Java 对象（String、List、Bitmap 等）</td></tr><tr><td>Dalvik Other</td><td>Dalvik 虚拟机的其他内存</td><td>Dex cache、JIT 代码、GC 元数据等</td></tr><tr><td>Stack</td><td>各线程的栈内存</td><td>每个线程约 512KB～1MB，线程多会增大</td></tr><tr><td>Ashmem</td><td>通过 &#x2F;dev&#x2F;ashmem分配</td><td>匿名共享内存</td></tr><tr><td>Gfx dev</td><td>GPU 图形设备内存</td><td>OpenGL &#x2F; Vulkan 缓冲、纹理、EGL surface</td></tr><tr><td>Other dev</td><td>其他设备驱动相关内存</td><td>例如音频 buffer、摄像头驱动缓冲区</td></tr><tr><td>.so mmap</td><td>通过 mmap 映射的共享库</td><td>C&#x2F;C++ 代码段和只读数据</td></tr><tr><td>.jar mmap</td><td>通过 mmap 映射的 jar 文件</td><td>一般为 framework.jar 等</td></tr><tr><td>.apk mmap</td><td>通过 mmap 映射的 apk 文件</td><td>资源访问（图片、xml、assets）</td></tr><tr><td>.ttf mmap</td><td>字体文件映射</td><td>字体缓存，少量常驻</td></tr><tr><td>.dex mmap</td><td>Dex 文件映射</td><td>ClassLoader 加载 dex 内存</td></tr><tr><td>.oat mmap</td><td>OAT 文件映射</td><td>运行时优化代码，常为只读</td></tr><tr><td>.art mmap</td><td>ART 虚拟机自身映射</td><td>ART runtime metadata</td></tr><tr><td>Other mmap</td><td>其他无法归类的 mmap 区域</td><td>一般是内存缓存或中间层分配</td></tr><tr><td>EGL mtrack</td><td>EGL 映射跟踪</td><td>GPU 图形缓冲区</td></tr><tr><td>GL mtrack</td><td>OpenGL 内存跟踪</td><td>GL 纹理、FrameBuffer、Shader cache</td></tr><tr><td>Unknown</td><td>未能分类的内存区域</td><td>可能是匿名 mmap、Binder、临时区域</td></tr></tbody></table><p>app Summary 各个项目的计算规则：</p><table><thead><tr><th>类别名</th><th>内存构成（计算规则）</th></tr></thead><tbody><tr><td>Java Heap</td><td>Dalvik Heap 的 Private Dirty  + .art mmap 的 Private Dirty  +  .art mmap 的 Private Clean</td></tr><tr><td>Native Heap</td><td>Native Heap 的 Private Dirty</td></tr><tr><td>Code</td><td>.so mmap.jar mmap.apk mmap.ttf mmap.dex mmap.oat mmap.ZygoteJIT.AppJIT上述 8 项的 Private Dirty + Private Clean 总和</td></tr><tr><td>Stack</td><td>Stack 的 Private Dirty</td></tr><tr><td>Graphics</td><td>Gfx devEGL mtrackGL mtrack上述 3 项的 Private Dirty + Private Clean 总和</td></tr><tr><td>Private Other</td><td>Total Private Dirty + Total Private Clean - Summary Java heap  - Summary Native Heap - Summary Code - Summary Stack -Summary Graphics</td></tr><tr><td>System</td><td>Total Pss - Total Private Dirty - Total Private Clean</td></tr><tr><td>TOTAL PSS</td><td>Summary Java Heap + Summary Native Heap + Summary Code + Summary Stack + Summary Graphics +  Summary Private Other + Summary System也等于 Native Heap 、Dalvik Heap、Dalvik Other、Stack、Ashmem、Gfx dev、Other dev、.so mmap、.jar mmap、.apk mmap、.ttf mmap、.dex mmap、.oat mmap、.art mmap、Other mmap、EGL mtrack、GL mtrack、Unknown 的 Pss Total 和 SwapPss Dirty 之和</td></tr><tr><td>TOTAL SWAP PSS</td><td>Native Heap 、Dalvik Heap、Dalvik Other、Stack、Ashmem、Gfx dev、Other dev、.so mmap、.jar mmap、.apk mmap、.ttf mmap、.dex mmap、.oat mmap、.art mmap、Other mmap、EGL mtrack、GL mtrack、Unknown 的 SwapPss Dirty 之和</td></tr></tbody></table><p>另外，也可以通过<code>dumpsys meminfo</code>的输出关注 Views、AppContexts、Activities 的数量，以判断是否有内存泄漏。</p><p>如果发现 <code>meminfo</code> 中输出的 Views 、Activities 异常增多时，需要关注是不是出现了 View 、Activities 的泄漏。</p><h3 id="分析引用库"><a href="#分析引用库" class="headerlink" title="分析引用库"></a>分析引用库</h3><p>在分析App不同版本的内存差异的时候，如果遇到 Code 段内存变化较大，可能是因为新版本引入了新的三方库，导致 dex 大小增加，进而导致在运行时的 Code 段内存增大（.dex mmap 或 .oat mmap 增加）。</p><p>这时候可以对比前后版本引用的库有哪些差异，以此作为依据，方便后续分析具体是哪些功能模块导致的 Code 段内存增加：</p><ol><li>通过 <code>gradlew app:dependencies --configuration releaseCompileClasspath</code> 获取 release 版引用的三方库列表</li><li>通过脚本将上一步的输出整理为表格，便于分析</li><li>根据结果可以大致知道新增了哪些三方库，dex文件增加大概是哪些三方库导致的</li><li>也可以通过分析哪些三方库是非必须的（这需要对业务比较了解）</li></ol><p>引用库对比在包大小分析中也很有用</p><h3 id="分析-java-heap"><a href="#分析-java-heap" class="headerlink" title="分析 java heap"></a>分析 java heap</h3><p>debuggable 的应用 (release 包可以通过在manifest中设置 debuggable &#x3D; true) 可以通过Android Studio Profiler 工具 dump java heap。 </p><p>如果是 root 过的手机，可以通过如下命令来 dump java heap。这种方式方便在执行自动化脚本的时候自动导出 java 堆。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pid 为进程<span class="built_in">id</span>, 最后一个参数为dump转储文件存放在手机上的路径，一般可以写shell有权限写的路径。</span></span><br><span class="line">adb shell am dumpheap [pid] /data/local/tmp/xxx.hprof</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行完上述命令后，可以通过 adb pull 命令将手机上的 dump 文件传到电脑上</span></span><br><span class="line">adb pull /data/local/tmp/xxx.hprof ~/xxx.hprof</span><br></pre></td></tr></table></figure><p>针对 release 包导出的 java heap 转储文件，大多数类都会被混淆：</p><p>可以借助 <a href="https://github.com/square/leakcanary/tree/main/shark">leakcanary-shark</a> 来解析 hprof 文件。同时，可以通过传入 mapping 文件，将对应的类、方法等名称还原：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hprofFile 为 java heap 转储文件</span></span><br><span class="line">Hprof.<span class="keyword">open</span>(hprofFile).use &#123; hprof -&gt;</span><br><span class="line">    <span class="comment">// mapping 为release 包对应的 mapping 文件</span></span><br><span class="line">    <span class="keyword">val</span> graph = HprofHeapGraph.indexHprof(hprof, ProguardMappingReader(File(mapping).inputStream()).readProguardMapping())</span><br><span class="line">    <span class="comment">// 之后就可以使用 graph 的相关 api 查询的 java 对象实例个数等信息,</span></span><br><span class="line">    <span class="comment">// 具体可参考: https://github.com/square/leakcanary/blob/main/shark/shark-graph/src/main/java/shark/HeapGraph.kt</span></span><br><span class="line">    graph.classes.forEach &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <a href="https://github.com/square/leakcanary/tree/main/shark">leakcanary-shark</a> 还可以做很多分析：</p><ol><li><p>开机内存分析：开机之后 dump java 堆，然后使用 <a href="https://github.com/square/leakcanary/tree/main/shark">leakcanary-shark</a> 分析开机时加载了哪些类，对应类加载了多少个实例。</p></li><li><p>View、Activity 等对象泄漏分析：前面提到 <code>meminfo</code> 会输出当前应用的 View、Activity 个数，使用 Java heap ，借助 <a href="https://github.com/square/leakcanary/tree/main/shark">leakcanary-shark</a> 可以方便输出 View、Activity 的个数以及其到 GC Root 引用链（借助<code>findShortestPathsFromGcRoots</code>），或者分析某些对象是否是泄漏的对象：</p></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Marks any instance of com.example.ThingWithLifecycle with</span></span><br><span class="line"><span class="comment">// ThingWithLifecycle.destroyed=true as leaking</span></span><br><span class="line"><span class="keyword">val</span> leakingObjectFilter =</span><br><span class="line">  <span class="keyword">object</span> : LeakingObjectFilter &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isLeakingObject</span><span class="params">(heapObject: <span class="type">HeapObject</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">if</span> (</span><br><span class="line">        heapObject <span class="keyword">is</span> HeapInstance &amp;&amp; heapObject instanceOf <span class="string">&quot;com.example.ThingWithLifecycle&quot;</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">val</span> destroyedField = heapObject[<span class="string">&quot;com.example.ThingWithLifecycle&quot;</span>, <span class="string">&quot;destroyed&quot;</span>]!!</span><br><span class="line">        destroyedField.value.asBoolean!!</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> leakingObjectFinder = FilteringLeakingObjectFinder(listOf(leakingObjectFilter))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> heapDumpFile = File(args[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">val</span> heapAnalysis =</span><br><span class="line">    Hprof.<span class="keyword">open</span>(heapDumpFile).use &#123; hprof -&gt;</span><br><span class="line">      <span class="keyword">val</span> heapGraph = HprofHeapGraph.indexHprof(hprof)</span><br><span class="line">      <span class="keyword">val</span> heapAnalyzer = HeapAnalyzer(&#123;&#125;)</span><br><span class="line">      heapAnalyzer.analyze(</span><br><span class="line">        heapDumpFile = heapDumpFile,</span><br><span class="line">        graph = heapGraph,</span><br><span class="line">        leakingObjectFinder = leakingObjectFinder,</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  println(heapAnalysis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，直接借助 Android Studio 也可以分析 java heap 转储文件：一般关注 <strong>Allocations、Shallow size、Retained size、Native size、Depth</strong> 这些属性：</p><p><img src="/.com//javaheap1.png"><br>这些属性的意义：</p><p><strong>Allocations：</strong> 只在类级别有。表示当前类有多少个存活的实例（对象）。</p><p><strong>Shallow size：</strong> 类级别和实例级别都有，且：</p><ul><li>类级别的 Shallow size 为某个类的所有实例的 Shallow size 之和。</li><li>实例级别的 Shallow size 为单个实例本身占用内存的大小。计算规则：当前对象所有非静态属性（包括从父类继承的属性）所占用的字节数总和。以一个Bitmap对象举例，其 Shallow size 为 62：</li></ul><p><img src="/.com//shallowsize.png"></p><table><thead><tr><th>属性</th><th>类型</th><th>内存</th><th>说明</th></tr></thead><tbody><tr><td>shadow$<em>klass</em></td><td>Class&lt;?&gt;（引用类型）</td><td>4</td><td>Android java.lang.Object 类特有的属性</td></tr><tr><td>shadow$<em>monitor</em></td><td>int</td><td>4</td><td>Android java.lang.Object 类特有的属性</td></tr><tr><td>mBitmapExt、mNinePatchChunk、mNinePatchInsets、mHardwareBuffer、mColorSpace、mGainmap</td><td>引用类型</td><td>6 * 4 &#x3D; 24</td><td>非值类型（引用类型）的属性都是占用 4 字节</td></tr><tr><td>mId、mNativePtr</td><td>long</td><td>8 * 2 &#x3D; 16</td><td>int,float 占4字节，long,double 占8字节，short,char占2个字节, byte,boolean 占1字节</td></tr><tr><td>mDensity、mHeight、mWidth</td><td>int</td><td>4 * 3 &#x3D; 12</td><td></td></tr><tr><td>mRecycled、mRequestPremultiplied</td><td>boolean</td><td>1 * 2 &#x3D; 2</td><td></td></tr></tbody></table><p><strong>Retained size：</strong> 类级别和实例级别都有，且：</p><p><strong>类级别的</strong> Retained size 是指该类的 Class 对象的 Retained size， 注意，它并不等于某个类的所有实例的 Retained size 之和。<strong>仍然以 Bitmap 举例：</strong></p><p><img src="/.com//retainedsize.png"></p><p>上图中类级别 Bitmap 的 Retained size 是 783。它等于对应的 Class 实例的 Retained size（可以选中某个Bitmap实例后，在其<code>shadow$_klass_</code>属性上右键-&gt;<code>Go to Instance</code>找到对应的 Class 实例 ）：</p><p><img src="/.com//instance.png"></p><ul><li>而实例级别的 <strong>Retained size</strong> 则表示单个对象被GC时所能回收到内存的总和，他的值总是 &gt;&#x3D; 单个实例的 Shallow size。举个例子：</li></ul><p><img src="/.com//tu1.gif" alt="图1" title="图1"><br><img src="/.com//tu1.gif" alt="图2" title="图2"></p><p>上面 2 个图中蓝色节点代表仅仅只有通过 obj1 才能直接或间接访问的对象。第一个图的 obj3 不是蓝色节点，因为其可以通过 GC Roots 访问。所以对于第一个图，obj1 的 retained size 是 obj1、obj2、obj4 的 shallow size 总和；第二个图的 retained size 是 obj1、obj2、obj3、obj4 的 shallow size 总和。obj2 的 retained size 可以通过相同的方式计算。</p><p><strong>Native size：</strong> 类级别和实例级别都有，实例级别的表示单个对象所引用的 native 内存大小。类级别则是所有实例引用的 native 内存总和。</p><p><strong>Depth</strong>： 从任意 GC Root 到选定实例的最短路径的深度，为 0 则表示可以作为GC Root, 为 1 则被 GC root 直接应用，以次类推。</p><p>在使用 Android Studio 对 java heap 进行分析时：</p><ol><li>Allocations 数比较大，且非 JDK 相关的对象需要关注。</li><li>Allocations 少但 Shallow size 比较大的对象，说明是大对象，需要重点关注。</li><li>Native Size 比较大的对象（一般为Bitmap），也需要重点关注</li></ol><h3 id="分析-smpas"><a href="#分析-smpas" class="headerlink" title="分析 smpas"></a>分析 smpas</h3><p>当要分析 .xxx mmap 等占用内存较多或者想要再具体了解 Native heap 、Java heap 内存都是那些模块占用了的时候，smaps 就比较有用。</p><p>可以通过如下命令抓取 smaps，前提是手机需要root：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pid 为进程<span class="built_in">id</span></span></span><br><span class="line">adb shell cat /proc/$pid/smaps &gt; ./smaps.log</span><br></pre></td></tr></table></figure><p>关于 smaps 文件结构的解读，可以参考这个文档：<a href="https://github.com/Gracker/Android-App-Memory-Analysis/blob/master/docs/zh/smaps_interpretation_guide.md">https://github.com/Gracker/Android-App-Memory-Analysis/blob/master/docs/zh/smaps_interpretation_guide.md</a></p><p>抓取之后可以通过 <a href="https://github.com/Gracker/Android-App-Memory-Analysis/blob/master/tools/smaps_parser.py">smaps_parser.py</a> 格式化输出，格式如下（原输出太长，有删减）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">Dalvik (Dalvik虚拟机运行时内存) : <span class="number">45.765</span> MB</span><br><span class="line">    PSS: <span class="number">45.765</span> MB</span><br><span class="line">        [anon:dalvik-main space (region space)] : <span class="number">34712</span> kB</span><br><span class="line">        [anon:dalvik-free list large <span class="keyword">object</span> space] : <span class="number">5211</span> kB</span><br><span class="line">        [anon:dalvik-non moving space] : <span class="number">4956</span> kB</span><br><span class="line">        [anon:dalvik-zygote space] : <span class="number">886</span> kB</span><br><span class="line">    SwapPSS: <span class="number">0.052</span> MB</span><br><span class="line">        [anon:dalvik-zygote space] : <span class="number">42</span> kB</span><br><span class="line">        [anon:dalvik-free list large <span class="keyword">object</span> space] : <span class="number">10</span> kB</span><br><span class="line"></span><br><span class="line">Dalvik Other (Dalvik虚拟机额外内存) : <span class="number">15.952</span> MB</span><br><span class="line">    PSS: <span class="number">15.952</span> MB</span><br><span class="line">        [anon:dalvik-LinearAlloc] : <span class="number">15196</span> kB</span><br><span class="line">        [anon:dalvik-region space live bitmap] : <span class="number">304</span> kB</span><br><span class="line">        [anon:dalvik-local ref table] : <span class="number">156</span> kB</span><br><span class="line">        [anon:dalvik-allocspace non moving space live-bitmap <span class="number">1</span>] : <span class="number">20</span> kB</span><br><span class="line">    SwapPSS: <span class="number">0.000</span> MB</span><br><span class="line"></span><br><span class="line">Stack (线程栈内存) : <span class="number">11.092</span> MB</span><br><span class="line">    PSS: <span class="number">11.092</span> MB</span><br><span class="line">        [anon:stack_and_tls:<span class="number">14216</span>] : <span class="number">228</span> kB</span><br><span class="line">        [stack] : <span class="number">164</span> kB</span><br><span class="line">        [anon:stack_and_tls:<span class="number">14909</span>] : <span class="number">136</span> kB</span><br><span class="line">        [anon:stack_and_tls:<span class="number">14908</span>] : <span class="number">136</span> kB</span><br><span class="line">        [anon:stack_and_tls:<span class="number">15051</span>] : <span class="number">132</span> kB</span><br><span class="line">    SwapPSS: <span class="number">0.000</span> MB</span><br><span class="line"></span><br><span class="line">Ashmem (匿名共享内存) : <span class="number">0.174</span> MB</span><br><span class="line">    PSS: <span class="number">0.174</span> MB</span><br><span class="line">        /dev/ashmem/shared_memory/9972DCF27EAD19B1851F16B6AC616BED (deleted) : <span class="number">128</span> kB</span><br><span class="line">        /dev/ashmem/shared_memory/76DA17E14D90B7C2CCCFA8ADCF6E788F (deleted) : <span class="number">32</span> kB</span><br><span class="line">        /dev/ashmem/fontMap (deleted) : <span class="number">12</span> kB</span><br><span class="line">        /dev/ashmem/GFXStats-<span class="number">14123</span> (deleted) : <span class="number">2</span> kB</span><br><span class="line">    SwapPSS: <span class="number">0.000</span> MB</span><br><span class="line"></span><br><span class="line">Other dev (其他设备内存) : <span class="number">0.105</span> MB</span><br><span class="line">    PSS: <span class="number">0.105</span> MB</span><br><span class="line">        /dev/binderfs/binder : <span class="number">64</span> kB</span><br><span class="line">        /dev/zero (deleted) : <span class="number">32</span> kB</span><br><span class="line">        /dev/binderfs/hwbinder : <span class="number">8</span> kB</span><br><span class="line">        /dev/__properties__/u:object_r:agp_support_anim_pause_render:s0 : <span class="number">1</span> kB</span><br><span class="line">    SwapPSS: <span class="number">0.000</span> MB</span><br><span class="line"></span><br><span class="line">.so mmap (动态链接库映射内存) : <span class="number">9.248</span> MB</span><br><span class="line">    PSS: <span class="number">9.248</span> MB</span><br><span class="line">        /vendor/lib64/libllvm-qgl.so : <span class="number">1518</span> kB</span><br><span class="line">        /system/lib64/libhwui.so : <span class="number">531</span> kB</span><br><span class="line">        /vendor/lib64/egl/libGLESv2_adreno.so : <span class="number">333</span> kB</span><br><span class="line">        /system/lib64/libandroid_runtime.so : <span class="number">139</span> kB</span><br><span class="line">    SwapPSS: <span class="number">0.001</span> MB</span><br><span class="line">        /system/lib64/libagp.so : <span class="number">1</span> kB</span><br><span class="line"></span><br><span class="line">.jar mmap (JAR文件映射内存) : <span class="number">2.175</span> MB</span><br><span class="line">    PSS: <span class="number">2.175</span> MB</span><br><span class="line">        /system/framework/framework.jar : <span class="number">1729</span> kB</span><br><span class="line">        /system/framework/framework-magic.jar : <span class="number">203</span> kB</span><br><span class="line">        /system/framework/ims-common.jar : <span class="number">8</span> kB</span><br><span class="line">        /system/framework/hwcustTelephony-common.jar : <span class="number">8</span> kB</span><br><span class="line">    SwapPSS: <span class="number">0.000</span> MB</span><br><span class="line"></span><br><span class="line">.apk mmap (APK文件映射内存) : <span class="number">129.413</span> MB</span><br><span class="line">    PSS: <span class="number">129.413</span> MB</span><br><span class="line">        /<span class="keyword">data</span>/app/~~xxxxx==/com.xxxx.xxxx-xxxx==/base.apk : <span class="number">109293</span> kB</span><br><span class="line">        /product/app/WebViewGoogle/WebViewGoogle.apk : <span class="number">19127</span> kB</span><br><span class="line">        /system/framework/framework-res-hnext.apk : <span class="number">122</span> kB</span><br><span class="line">    SwapPSS: <span class="number">0.000</span> MB</span><br><span class="line"></span><br><span class="line">.ttf mmap (字体文件映射内存) : <span class="number">9.257</span> MB</span><br><span class="line">    PSS: <span class="number">9.257</span> MB</span><br><span class="line">        /system/fonts/HONORSansVFCN.ttf : <span class="number">7376</span> kB</span><br><span class="line">    SwapPSS: <span class="number">0.000</span> MB</span><br><span class="line"></span><br><span class="line">.dex mmap (DEX字节码文件映射内存) : <span class="number">5.195</span> MB</span><br><span class="line">    PSS: <span class="number">5.195</span> MB</span><br><span class="line">        /<span class="keyword">data</span>/dalvik-cache/arm64/<span class="symbol">product@</span><span class="symbol">app@</span><span class="symbol">WebViewGoogle@</span>WebViewGoogle.<span class="symbol">apk@</span>classes.vdex : <span class="number">1225</span> kB</span><br><span class="line">        /<span class="keyword">data</span>/dalvik-cache/arm64/<span class="symbol">product@</span><span class="symbol">app@</span><span class="symbol">WebViewGoogle@</span>WebViewGoogle.<span class="symbol">apk@</span>classes.dex : <span class="number">121</span> kB</span><br><span class="line">        [anon:dalvik-/system/framework/framework.jar-classes3.dex-transformed] : <span class="number">20</span> kB</span><br><span class="line">        /memfd:/system/framework/arm64/boot.vdex (deleted) : <span class="number">17</span> kB</span><br><span class="line">    SwapPSS: <span class="number">0.000</span> MB</span><br><span class="line"></span><br><span class="line">.oat mmap (编译后的安卓应用程序映射内存) : <span class="number">0.018</span> MB</span><br><span class="line">    PSS: <span class="number">0.018</span> MB</span><br><span class="line">        /memfd:/system/framework/arm64/boot.oat (deleted) : <span class="number">18</span> kB</span><br><span class="line">    SwapPSS: <span class="number">0.000</span> MB</span><br><span class="line"></span><br><span class="line">.art mmap (ART运行时文件映射内存) : <span class="number">7.728</span> MB</span><br><span class="line">    PSS: <span class="number">7.728</span> MB</span><br><span class="line">        /memfd:/boot-image-methods.art (deleted) : <span class="number">6577</span> kB</span><br><span class="line">        [anon:dalvik-/system/framework/boot.art] : <span class="number">1146</span> kB</span><br><span class="line">        /memfd:/system/framework/arm64/boot.art (deleted) : <span class="number">5</span> kB</span><br><span class="line">    SwapPSS: <span class="number">0.026</span> MB</span><br><span class="line">        [anon:dalvik-/system/framework/boot.art] : <span class="number">26</span> kB</span><br></pre></td></tr></table></figure><p>针对 .xxx mmap 这类映射内存，smaps 可以很清晰地看出是哪些文件映射的内存，有多大。但是对于 java heap 尤其是 native heap 使用 smaps 就比较难分析了。</p><h3 id="分析线程快照"><a href="#分析线程快照" class="headerlink" title="分析线程快照"></a>分析线程快照</h3><p>debuggable 的应用可以通过 Android Studio 的 debug 工具 dump 当前应用的线程快照。但是这个只能导出 java 的线程。如果是纯 native 的线程则没法用这种方式导出</p><p><img src="/.com//threads.png"><br>Android Studio profiler 工具在查看实时内存信息的时候也会显示当前应用的线程数量，但是没法展示当前的所有线程的快照</p><p><img src="/.com//threads2.png"><br>root 的手机可以通过如下命令 dump 当前应用的所有线程快照（包括 native 线程）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pid 表示应用的进程<span class="built_in">id</span></span></span><br><span class="line">adb shell debuggerd -b $PID &gt; .threads_dump.log</span><br></pre></td></tr></table></figure><p>输出内容如下（节选）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&quot;u.input_hihonor&quot; sysTid=11298</span><br><span class="line">    #00 pc 00000000000c1188  /apex/com.android.runtime/lib64/bionic/libc.so (__epoll_pwait+8) (BuildId: 3a5961502c37ecb11e3ee0defe2600bb)</span><br><span class="line">    #01 pc 0000000000011f7c  /system/lib64/libutils.so (android::Looper::pollOnce(int, int*, int*, void**)+212) (BuildId: ca44f7bb04e1ac79b71c5ff2900fb995)</span><br><span class="line">    #02 pc 00000000001be784  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, long, int)+44) (BuildId: cf508d4b956d9fcaf87dad152decb09b)</span><br><span class="line">    #03 pc 0000000000399170  /apex/com.android.art/lib64/libart.so (art_quick_generic_jni_trampoline+144) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #04 pc 0000000002038cc4  /memfd:jit-zygote-cache (deleted) (offset 0x2000000) (android.os.MessageQueue.next+292)</span><br><span class="line">    #05 pc 00000000028f4f84  /memfd:jit-zygote-cache (deleted) (offset 0x2000000) (android.os.Looper.loopOnce+100)</span><br><span class="line">    #06 pc 000000000205ed7c  /memfd:jit-zygote-cache (deleted) (offset 0x2000000) (android.os.Looper.loop+284)</span><br><span class="line">    #07 pc 000000000253670c  /memfd:jit-zygote-cache (deleted) (offset 0x2000000) (android.app.ActivityThread.main+3852)</span><br><span class="line">    #08 pc 0000000000382c40  /apex/com.android.art/lib64/libart.so (art_quick_invoke_static_stub+640) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #09 pc 000000000037e684  /apex/com.android.art/lib64/libart.so (_jobject* art::InvokeMethod&lt;(art::PointerSize)8&gt;(art::ScopedObjectAccessAlreadyRunnable const&amp;, _jobject*, _jobject*, _jobject*, unsigned long)+732) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #10 pc 00000000006b4bc8  /apex/com.android.art/lib64/libart.so (art::Method_invoke(_JNIEnv*, _jobject*, _jobject*, _jobjectArray*) (.__uniq.165753521025965369065708152063621506277)+32) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #11 pc 0000000000399170  /apex/com.android.art/lib64/libart.so (art_quick_generic_jni_trampoline+144) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #12 pc 0000000002ce0464  /memfd:jit-zygote-cache (deleted) (offset 0x2000000) (com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run+132)</span><br><span class="line">    #13 pc 0000000000760444  /apex/com.android.art/lib64/libart.so (nterp_helper+7636) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #14 pc 00000000002eb676  /system/framework/framework.jar (com.android.internal.os.ZygoteInit.main+690)</span><br><span class="line"></span><br><span class="line">&quot;Jit thread pool&quot; sysTid=11308</span><br><span class="line">    #00 pc 0000000000083cbc  /apex/com.android.runtime/lib64/bionic/libc.so (syscall+28) (BuildId: 3a5961502c37ecb11e3ee0defe2600bb)</span><br><span class="line">    #01 pc 0000000000266780  /apex/com.android.art/lib64/libart.so (art::ConditionVariable::WaitHoldingLocks(art::Thread*)+152) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #02 pc 00000000006592cc  /apex/com.android.art/lib64/libart.so (art::ThreadPoolWorker::Run()+208) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #03 pc 00000000004d9298  /apex/com.android.art/lib64/libart.so (art::ThreadPoolWorker::Callback(void*)+164) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #04 pc 000000000006eafc  /apex/com.android.runtime/lib64/bionic/libc.so (__pthread_start(void*)+196) (BuildId: 3a5961502c37ecb11e3ee0defe2600bb)</span><br><span class="line">    #05 pc 0000000000061664  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+64) (BuildId: 3a5961502c37ecb11e3ee0defe2600bb)</span><br><span class="line"></span><br><span class="line">&quot;HeapTaskDaemon&quot; sysTid=11309</span><br><span class="line">    #00 pc 0000000000083cbc  /apex/com.android.runtime/lib64/bionic/libc.so (syscall+28) (BuildId: 3a5961502c37ecb11e3ee0defe2600bb)</span><br><span class="line">    #01 pc 0000000000266780  /apex/com.android.art/lib64/libart.so (art::ConditionVariable::WaitHoldingLocks(art::Thread*)+152) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #02 pc 00000000003123c0  /apex/com.android.art/lib64/libart.so (art::gc::TaskProcessor::RunAllTasks(art::Thread*)+912) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #03 pc 0000000000399170  /apex/com.android.art/lib64/libart.so (art_quick_generic_jni_trampoline+144) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #04 pc 0000000002406b80  /memfd:jit-zygote-cache (deleted) (offset 0x2000000) (java.lang.Daemons$HeapTaskDaemon.runInternal+192)</span><br><span class="line">    #05 pc 000000000240408c  /memfd:jit-zygote-cache (deleted) (offset 0x2000000) (java.lang.Daemons$Daemon.run+124)</span><br><span class="line">    #06 pc 000000000211960c  /memfd:jit-zygote-cache (deleted) (offset 0x2000000) (java.lang.Thread.run+76)</span><br><span class="line">    #07 pc 0000000000382974  /apex/com.android.art/lib64/libart.so (art_quick_invoke_stub+612) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #08 pc 000000000036986c  /apex/com.android.art/lib64/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+132) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #09 pc 000000000093fac8  /apex/com.android.art/lib64/libart.so (art::detail::ShortyTraits&lt;(char)86&gt;::Type art::ArtMethod::InvokeInstance&lt;(char)86&gt;(art::Thread*, art::ObjPtr&lt;art::mirror::Object&gt;, art::detail::ShortyTraits&lt;&gt;::Type...)+60) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #10 pc 00000000004cf6ec  /apex/com.android.art/lib64/libart.so (art::Thread::CreateCallback(void*)+1604) (BuildId: eb9d19ca5eb7e6238e0a904aee97c2d7)</span><br><span class="line">    #11 pc 000000000006eafc  /apex/com.android.runtime/lib64/bionic/libc.so (__pthread_start(void*)+196) (BuildId: 3a5961502c37ecb11e3ee0defe2600bb)</span><br><span class="line">    #12 pc 0000000000061664  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+64) (BuildId: 3a5961502c37ecb11e3ee0defe2600bb)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过线程快照可以用于分析当前应用有多少个线程正在运行，这些线程是属于哪些模块，可以帮助辅助定位一些线程数量多导致的内存或其他性能问题（比如耗电）。</p><h3 id="分析-native-内存泄漏"><a href="#分析-native-内存泄漏" class="headerlink" title="分析 native 内存泄漏"></a>分析 native 内存泄漏</h3><p>native 内存不像 java heap 那样可以 dump 整个堆进行分析，要进行内存泄漏分析也不容易。这里主要介绍 3 个工具</p><h4 id="Perfetto-跟踪-Native-Allocations"><a href="#Perfetto-跟踪-Native-Allocations" class="headerlink" title="Perfetto 跟踪 Native Allocations"></a>Perfetto 跟踪 Native Allocations</h4><p>Perfetto 工具基本使用方式可以参考这位博主的系列文章：<a href="https://androidperformance.com/2024/05/21/Android-Perfetto-01-What-is-perfetto/">https://androidperformance.com/2024/05/21/Android-Perfetto-01-What-is-perfetto/</a> </p><p>用 Perfetto 可以实时跟踪 Native 层的内存分配（通过 malloc、calloc 之类的方法分配的内存），它跟使用 Android Studio 中的 Track Memory Consumption（Native Allocations）是一样的，只是可以配置的参数更多、更自由，也更适合用自动化脚本处理。</p><p><img src="/.com//perfetto.png"></p><p>具体方式是：</p><ul><li>下载这个 python 脚本：<a href="https://raw.githubusercontent.com/google/perfetto/refs/heads/main/tools/heap_profile">https://raw.githubusercontent.com/google/perfetto/refs/heads/main/tools/heap_profile</a>，保存为 <code>heap_profile.py</code></li><li>使用<code>python3 ~/Downloads/heap_profile.py -o ~/Downloads/native_heap/</code> 命令开始抓取。其中 -o 参数表示产物输出目录，需要是一个空目录</li><li>在适当的时候按 <code>ctrl+c</code> 终止上述命令，之后产物会保存在 <code>-o</code>参数指定的目录。然后可以用 <a href="https://ui.perfetto.dev/#!/">https://ui.perfetto.dev/#!&#x2F;</a> 打开对应的文件：</li></ul><p><img src="/.com//nativeheapdump.png"></p><p>抓取的数据中会显示采样聚合的 native 内存分配调用栈，可以有四个维度展示这些调用栈：</p><pre><code>* Unreleased Malloc Size：申请但是没有释放的内存大小* Unreleased Malloc Count：申请但是没有释放的次数（相关于 申请次数 - 释放次数）* Total Malloc Size：申请内存的总大小* Total Malloc Count：申请内存的总次数</code></pre><p>一般需要关注<code>Unreleased Malloc Size</code>，这部分可能是内存泄漏，当然也不绝对，有可能这部分内存只是还不到释放的时机，不应该释放。需要根据堆栈 case by case 分析处理。</p><h4 id="koom-native-leak"><a href="#koom-native-leak" class="headerlink" title="koom-native-leak"></a>koom-native-leak</h4><p><a href="https://github.com/KwaiAppTeam/KOOM/tree/master/koom-native-leak">koom-native-leak</a> 是快手开发的用于监控 Native 内存泄漏的库。它通过 hook malloc&#x2F;free 等内存分配器方法来跟踪记录内存分配与回收，以分析是否有内存泄漏。</p><p>详情可见：<a href="https://github.com/KwaiAppTeam/KOOM/blob/master/koom-native-leak/README.zh-CN.md">https://github.com/KwaiAppTeam/KOOM/blob/master/koom-native-leak/README.zh-CN.md</a></p><p>需要说明的是：测试下来 <a href="https://github.com/KwaiAppTeam/KOOM/tree/master/koom-native-leak">koom-native-leak</a> 目前只在 Android 10 （API 29）的设备上有效果，其他版本基本抓不到任何 native 内存泄漏的 case 。</p><h4 id="MemoryLeakDetector"><a href="#MemoryLeakDetector" class="headerlink" title="MemoryLeakDetector"></a>MemoryLeakDetector</h4><p><a href="https://github.com/bytedance/memory-leak-detector/blob/master/README_cn.md">MemoryLeakDetector</a> (Raphael) 是字节跳动开发的用于监控 Native 内存泄漏的库。原理同 koom-native-leak 类似，都是通过 hook malloc&#x2F;free 等内存分配器方法来记录内存的分配和回收。不过 MemoryLeakDetector 兼容性更好一些，目前测试下来各个版本的系统都没有遇到大问题。</p><p>关于 <a href="https://github.com/bytedance/memory-leak-detector/blob/master/README_cn.md">MemoryLeakDetector</a> 详情可见官方文档：<a href="https://github.com/bytedance/memory-leak-detector">https://github.com/bytedance/memory-leak-detector</a></p><p>需要说明的是：MemoryLeakDetector mmap 也会监控 mmap 等函数。但对于内存分析来说，使用 mmap 申请的内存，并不代表实际使用的内存，在未实际使用对应的内存时，是不计入 PSS 中。</p><p>另外，还需要注意的是无论是 <a href="https://github.com/bytedance/memory-leak-detector/blob/master/README_cn.md">MemoryLeakDetector</a> 还是 <a href="https://github.com/KwaiAppTeam/KOOM/tree/master/koom-native-leak">koom-native-leak</a> ，都不能保证检测到的未释放内存 100% 就是内存泄漏，也不能保证能保证所有的内存泄漏都能被检测到。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;内存分析方法的一些记录与总结&lt;/p&gt;</summary>
    
    
    
    <category term="内存分析" scheme="https://www.likebamboo.com/categories/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/"/>
    
    
    <category term="内存" scheme="https://www.likebamboo.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>日常工作工具 Tips</title>
    <link href="https://www.likebamboo.com/2025/10/18/some-tips/"/>
    <id>https://www.likebamboo.com/2025/10/18/some-tips/</id>
    <published>2025-10-17T16:00:00.000Z</published>
    <updated>2025-10-29T12:10:40.746Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h3 id="解压并反编译-python-打包的-exe-文件"><a href="#解压并反编译-python-打包的-exe-文件" class="headerlink" title="解压并反编译 python 打包的 exe 文件"></a>解压并反编译 python 打包的 exe 文件</h3><p><strong>1，下载 pyinstxtractor.py，将 exe 文件解压转换成 pyc 文件</strong></p><p>在 <a href="https://github.com/extremecoders-re/pyinstxtractor">https://github.com/extremecoders-re/pyinstxtractor</a> 下载 pyinstxtractor.py 到任意目录</p><p>然后执行 <code>python pyinstxtractor.py test.exe</code> 解压 exe 得到编译后的 python。</p><p><strong>注意：</strong> 你需要使用和打包 exe 时一样的 python 版本，否则可能会出现类似如下提示，某些资源无法解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[!] Warning: This script is running in a different Python version than the one used to build the executable. </span><br><span class="line">[!] Please run this script in Python 3.7 to prevent extraction errors during unmarshalling </span><br><span class="line">[!] Skipping pyz extraction</span><br></pre></td></tr></table></figure><p><strong>2，使用 pycdc 将 pyc 反编译成 py 文件</strong></p><p>克隆 pycdc 仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zrax/pycdc.git</span><br><span class="line">cd pycdc</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>反编译 .pyc 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pycdc 1client.pyc &gt; client.py</span><br></pre></td></tr></table></figure><p>另见 <a href="https://crackmes.cn/doc/157/">https://crackmes.cn/doc/157/</a></p><h3 id="无需登录下载-oracle-jdk"><a href="#无需登录下载-oracle-jdk" class="headerlink" title="无需登录下载 oracle jdk"></a>无需登录下载 oracle jdk</h3><p>adobe 提供的下载： <a href="https://helpx.adobe.com/coldfusion/kb/coldfusion-downloads.html#downloads3">https://helpx.adobe.com/coldfusion/kb/coldfusion-downloads.html#downloads3</a></p><blockquote><p>主要是 oracle jdk 执行 <code>java -version</code> 输出的是 <code>java version xx.xx.xx</code>, 而其他 openjdk 输出的是 <code>openjdk version xx.xx.xx</code> , 而 MTN 工具要求输出的是 <code>java version</code>, 且仅支持 1.8、1.9 版本</p></blockquote><h3 id="Windows-下-android-usb-驱动"><a href="#Windows-下-android-usb-驱动" class="headerlink" title="Windows 下 android usb 驱动"></a>Windows 下 android usb 驱动</h3><ol><li><p>各个 OEM 厂商的驱动： <a href="https://developer.android.google.cn/studio/run/oem-usb?hl=zh-cn#Drivers">https://developer.android.google.cn/studio/run/oem-usb?hl=zh-cn#Drivers</a></p><ul><li>荣耀手机需要安装荣耀手机助理： <a href="https://www.honor.com/cn/tech/honor-suite/">https://www.honor.com/cn/tech/honor-suite/</a></li></ul></li><li><p>Google USB 驱动： <a href="https://developer.android.google.cn/studio/run/win-usb?hl=zh-cn">https://developer.android.google.cn/studio/run/win-usb?hl=zh-cn</a></p></li></ol><h4 id="Android-Studio-旧版本下载"><a href="#Android-Studio-旧版本下载" class="headerlink" title="Android Studio 旧版本下载"></a>Android Studio 旧版本下载</h4><p><a href="https://developer.android.com/studio/archive">https://developer.android.com/studio/archive</a> 注意一定要把语言切换为 English，中文页面下会出现【抱歉，找不到该页面错误】</p><h4 id="腾讯-Android-SDK-镜像"><a href="#腾讯-Android-SDK-镜像" class="headerlink" title="腾讯 Android SDK 镜像"></a>腾讯 Android SDK 镜像</h4><p><a href="https://mirrors.cloud.tencent.com/AndroidSDK/">https://mirrors.cloud.tencent.com/AndroidSDK/</a></p><h4 id="perfetto-分析-Native-内存泄漏"><a href="#perfetto-分析-Native-内存泄漏" class="headerlink" title="perfetto 分析 Native 内存泄漏"></a>perfetto 分析 Native 内存泄漏</h4><ol><li><p>在 <a href="https://github.com/google/perfetto/tree/main/tools">https://github.com/google/perfetto/tree/main/tools</a> 下载 <code>heap_profile</code> , 保存为 <code>heap_profile.py</code></p></li><li><p>使用 <code>python3 heap_profile.py -o empty_dir</code>, 其中 <code>empty_dir</code> 是一个空目录的路径。记住一定是一个空目录。另外还可以设置其他一些参数，直接看 <code>heap_profile.py</code> 里的代码即可</p></li></ol><h4 id="代码中-Native-内存泄漏"><a href="#代码中-Native-内存泄漏" class="headerlink" title="代码中 Native 内存泄漏"></a>代码中 Native 内存泄漏</h4><ol><li><p>koom-native-leak: <a href="https://github.com/KwaiAppTeam/KOOM/tree/master/koom-native-leak">https://github.com/KwaiAppTeam/KOOM/tree/master/koom-native-leak</a> , Android 10(api 29) 的设备上正常，再往后就抓不到了，不太实用</p></li><li><p>MemoryLeakDetector: <a href="https://github.com/bytedance/memory-leak-detector">https://github.com/bytedance/memory-leak-detector</a> ，字节跳动 Raphael，使用比较方便。自己改了下源码，支持最多 32 层栈输出：<a href="https://github.com/likebamboo/memory-leak-detector">https://github.com/likebamboo/memory-leak-detector</a></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作中的一些小的 tip&lt;/p&gt;</summary>
    
    
    
    <category term="tips" scheme="https://www.likebamboo.com/categories/tips/"/>
    
    
    <category term="tips" scheme="https://www.likebamboo.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>2019年书单</title>
    <link href="https://www.likebamboo.com/2019/12/31/book-list-2019/"/>
    <id>https://www.likebamboo.com/2019/12/31/book-list-2019/</id>
    <published>2019-12-30T16:00:00.000Z</published>
    <updated>2025-10-29T12:10:40.743Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><ol><li>《漫画算法–小灰的算法之旅》</li><li>《OpenGL ES 3.0编程指南》(在读)</li></ol><p>…</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>《有话说》 (完成)</li><li>《爱你就像爱生命》 (完成)</li><li>《谁杀了他》 (完成)</li><li>《美国陷阱》 (完成)</li><li>《一个叫欧维的男人决定去死》 (完成)</li><li>《鲁迅全集》 (已读呐喊、彷徨、野草集等)</li></ol><p>…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2019年读书书单&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://www.likebamboo.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="读书" scheme="https://www.likebamboo.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>2018年书单</title>
    <link href="https://www.likebamboo.com/2018/12/31/book-list-2018/"/>
    <id>https://www.likebamboo.com/2018/12/31/book-list-2018/</id>
    <published>2018-12-30T16:00:00.000Z</published>
    <updated>2025-10-29T12:10:40.742Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><ol><li><p>《算法图解》 (完成)</p></li><li><p>《图解HTTP》 (完成)</p></li><li><p>《设计模式之禅(第二版)》 (完成)</p></li></ol><p>…</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><p>《非暴力沟通》 (完成)</p></li><li><p>《三体》全集  (完成)</p></li><li><p>《月亮与6便士》 (完成)</p></li><li><p>《万历十五年》 (完成)</p></li><li><p>《云边有个小卖部》 (完成)</p></li><li><p>《谁杀了她》 (完成)</p></li><li><p>《百年孤独》 (完成)</p></li><li><p>《黄金时代》 (完成)</p></li><li><p>《流浪地球》 (完成)</p></li></ol><p>…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2018年读书书单&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://www.likebamboo.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="读书" scheme="https://www.likebamboo.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Gradle插件开发基础</title>
    <link href="https://www.likebamboo.com/2018/03/01/gradle-plugin/"/>
    <id>https://www.likebamboo.com/2018/03/01/gradle-plugin/</id>
    <published>2018-02-28T16:00:00.000Z</published>
    <updated>2025-10-29T12:10:40.743Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h3 id="Gradle插件是什么"><a href="#Gradle插件是什么" class="headerlink" title="Gradle插件是什么"></a>Gradle插件是什么</h3><p>Gradle插件将可重复使用的构建逻辑封装起来，可用于许多不同的项目和构建。 Gradle插件就相当于jar包，里面封装了一些共有的方法以及一些自定义的<code>task</code>等。</p><h3 id="如何开发Gradle插件"><a href="#如何开发Gradle插件" class="headerlink" title="如何开发Gradle插件"></a>如何开发Gradle插件</h3><p>可以使用任何语言开发Gradle插件，只要最终生成字节码就行。一般常用的语言是<code>Groovy</code>、<code>Java</code>、<code>Kotlin</code>。</p><p>下面以<code>Groovy</code>语言为例(IDE使用<code>Intellij Idea</code>)，介绍Gradle插件开发的流程：</p><p>1, 首先需要创建一个工程，然后新建一个名为<code>my-plugin</code>的模块，模块类型选<code>Gradle</code>，语言选择<code>Groovy</code>（如果使用的是<code>Android studio</code>可以新建一个<code>Java</code>模块，然后将<code>main/java/</code>文件夹改名为<code>main/groovy</code>）<br><img src="/.com//1519961761561.png" alt="Alt text"></p><p>2, 修改<code>build.gradle</code>，增加对<code>gradle sdk</code> 和<code>groovy sdk</code>的依赖：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入groovy插件，用于编译groovy等</span></span><br><span class="line">apply plugin: <span class="string">&#x27;groovy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    testCompile <span class="keyword">group</span>: <span class="string">&#x27;junit&#x27;</span>, name: <span class="string">&#x27;junit&#x27;</span>, version: <span class="string">&#x27;4.12&#x27;</span></span><br><span class="line">    <span class="comment">// 依赖Gradle sdk，插件开发中需要用到gradle的api</span></span><br><span class="line">    <span class="keyword">compile</span> gradleApi()</span><br><span class="line">    <span class="comment">// 依赖groovy sdk</span></span><br><span class="line">    <span class="keyword">compile</span> localGroovy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3, 准备工作做好后就可以开始编写插件了。在<code>groovy</code>目录下新建名为<code>MyPlugin</code>的类(<strong>注意：<code>groovy</code>类文件的后缀是<code>groovy</code></strong>)</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pptv.plugin</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPlugin</span> <span class="keyword">implements</span> <span class="title class_">Plugin</span>&lt;Project&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">void</span> apply(Project project) &#123;</span><br><span class="line">        project.tasks.create(<span class="string">&quot;my-task&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义插件必须实现<code>Plugin</code>接口，覆盖其<code>apply</code>方法，并在<code>apply</code>方法中完成该自定义插件的功能。上述代码中创建了一个名为<code>my-task</code>的<code>task</code>，但该<code>task</code>什么也不做。</p><p>4, 插件写好后，要想在其他项目或模块中使用该插件，需要先发布插件。</p><h3 id="发布插件"><a href="#发布插件" class="headerlink" title="发布插件"></a>发布插件</h3><p>1, 首先需要在插件模块的<code>resources</code>目录下新建<code>META-INF/gradle-plugins</code>目录，然后再在<code>gradle-plugins</code>目录下新建一个<code>properties</code>属性文件，文件名称可以任意，但最好与项目功能相关，因为之后会用到这个文件名。然后在该文件中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-class=com.pptv.plugin.MyPlugin</span><br></pre></td></tr></table></figure><p>其中<code>implementation-class</code>属性的值就是刚才新建的<code>MyPlugin</code>类的类名(带包名)。</p><p>2, 在插件模块的<code>build.gradle</code>中新增<code>uploadArchives</code>节点，用于配置<strong>发布插件</strong>所需的信息：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        <span class="comment">// 以下用于将插件发布到本地</span></span><br><span class="line">        <span class="keyword">flatDir</span> &#123;</span><br><span class="line">            name <span class="string">&quot;localRepository&quot;</span></span><br><span class="line">            dir <span class="string">&quot;$&#123;getRootDir()&#125;$&#123;File.separator&#125;build&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以下可用于将插件发布到私有maven仓库</span></span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">&quot;http://maven.pptv.com/repositories/&quot;</span></span><br><span class="line">            credentials &#123;</span><br><span class="line">                username <span class="string">&quot;$&#123;props[&#x27;MAVEN_REPO_USERNAME&#x27;]&#125;&quot;</span></span><br><span class="line">                password <span class="string">&quot;$&#123;props[&#x27;MAVEN_REPO_PASSWORD&#x27;]&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下也可用于将插件发布到私有maven仓库, 且可以配置的内容更多些</span></span><br><span class="line">        <span class="comment">// apply plugin: &#x27;maven&#x27;</span></span><br><span class="line">        <span class="comment">// mavenDeployer &#123;</span></span><br><span class="line">        <span class="comment">//     repository (url:&quot;http://maven.pptv.com/repositories/&quot;)&#123;</span></span><br><span class="line">        <span class="comment">//         authentication (userName:&quot;$&#123;props[&#x27;MAVEN_REPO_USERNAME&#x27;]&#125;&quot;, password:&quot;$&#123;props[&#x27;MAVEN_REPO_PASSWORD&#x27;]&#125;&quot;)</span></span><br><span class="line">        <span class="comment">//         pom.groupId =  &quot;$&#123;GROUP_ID&#125;&quot;</span></span><br><span class="line">        <span class="comment">//         pom.artifactId = project.getName()</span></span><br><span class="line">        <span class="comment">//         pom.version =  &quot;$&#123;VERSION_NAME&#125;&quot;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(完整的<code>build.gradle</code>见文章最后)<br>其中: </p><ul><li><code>flatDir</code>节点用于配置将插件发布到本地时，插件存放的目录(<code>dir</code>) 信息；</li><li><code>maven</code> 节点用于配置将插件发布到远端maven仓库，需配置远端仓库的<code>url</code>和账号信息(<code>credentials</code>)；</li><li>注释掉的<code>mavenDeployer</code>节点也可以用于将插件发布到maven仓库，但这个配置需要依赖maven插件(<code>apply plugin: &#39;maven&#39;</code>)。 其中注释掉的代码中<code>${GROUP_ID}</code>和<code>${VERSION_NAME}</code>的定义如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// group id</span><br><span class="line">def GROUP_ID = &quot;com.pptv.plugin&quot;</span><br><span class="line">// 版本</span><br><span class="line">def VERSION_NAME = &quot;1.0.0&quot;</span><br><span class="line"></span><br><span class="line">group &quot;$&#123;GROUP_ID&#125;&quot;</span><br><span class="line">version &quot;$&#123;VERSION_NAME&#125;&quot;</span><br></pre></td></tr></table></figure><ul><li>具体要将插件发布到本地还是远端，可以自己选择。</li></ul><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>插件开发完成后，要在其他项目或模块中使用，需要在其他项目的根<code>build.gradle</code>中加入如下配置：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        <span class="comment">// 本地库配置</span></span><br><span class="line">        <span class="keyword">flatDir</span> &#123;</span><br><span class="line">            name <span class="string">&quot;localRepository&quot;</span></span><br><span class="line">            <span class="comment">// 本地插件存放的路径</span></span><br><span class="line">            dir <span class="string">&quot;$&#123;getRootDir()&#125;$&#123;File.separator&#125;build&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 远端库配置</span></span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">&quot;http://maven.pptv.com/repositories/&quot;</span></span><br><span class="line">            credentials &#123;</span><br><span class="line">                username <span class="string">&quot;$&#123;props[&#x27;MAVEN_REPO_USERNAME&#x27;]&#125;&quot;</span></span><br><span class="line">                password <span class="string">&quot;$&#123;props[&#x27;MAVEN_REPO_PASSWORD&#x27;]&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="comment">// 导入插件库， 格式为 -&gt; group:module:version</span></span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">&quot;com.pptv.plugin:my-plugin:1.0.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述配置中：</p><ul><li><code>flatDir</code>节点的配置同<strong>发布插件</strong>的配置，指明了插件在本地存放的位置信息；</li><li><code>maven</code>节点的配置同<strong>发布插件</strong>的配置，指明了远端仓库的<code>url</code>等信息；</li><li><code>dependencies</code>节点的<code>classpath</code>属性的取值格式是<code>group:插件module名称:插件版本号version</code>。</li></ul><p>然后需要在使用插件的模块的<code>build.gradle</code>中添加:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#x27;my-plugin&#x27;</span><br></pre></td></tr></table></figure><p>其中<code>my-plugin</code>为插件模块<code>resources/META-INF/gradle-plugins</code>下<code>properties</code>文件的文件名(该名称可以和插件模块的名称不相同)。</p><p>刷新下项目，在Gradle视图窗口中就可以看到自定义插件创建的 <code>my-task</code>了：<br><img src="/.com//1519962964535.png" alt="Alt text"></p><p>至此，一个简单的Gradle插件就开发完成了。</p><p><strong>插件模块完整 <a href="./build.gradle">build.gradle</a></strong></p><blockquote><p>参考 ： <a href="https://docs.gradle.org/current/userguide/userguide_single.html#custom_plugins">https://docs.gradle.org/current/userguide/userguide_single.html#custom_plugins</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Gradle插件将可重复使用的构建逻辑封装起来，可用于许多不同的项目和构建。 Gradle插件就相当于jar包，里面封装了一些共有的方法以及一些自定义的task等。&lt;/p&gt;</summary>
    
    
    
    <category term="gradle" scheme="https://www.likebamboo.com/categories/gradle/"/>
    
    
    <category term="gradle" scheme="https://www.likebamboo.com/tags/gradle/"/>
    
    <category term="插件" scheme="https://www.likebamboo.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用动态代理实现Wifi网络下模拟3g/4g</title>
    <link href="https://www.likebamboo.com/2017/08/08/android-wifi-hook/"/>
    <id>https://www.likebamboo.com/2017/08/08/android-wifi-hook/</id>
    <published>2017-08-07T16:00:00.000Z</published>
    <updated>2025-10-29T12:10:40.742Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>最近做的需求需要频繁使用3G&#x2F;4G网络，可惜公司给的测试卡流量只有几百M，播几个视频流量就耗光了，测试起来非常不方便。于是就想没有什么工具或者软件可以在wifi环境下模拟3G&#x2F;4G网络，在网上找半天，结果无功而返。</p><p>既然没有软件能做到，那只能从代码层面下手了。代码中判断当前手机网络类型的代码比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMobileNetwork</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="type">ConnectivityManager</span> <span class="variable">cm</span> <span class="operator">=</span> (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (cm == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">NetworkInfo</span> <span class="variable">info</span> <span class="operator">=</span> cm.getActiveNetworkInfo();</span><br><span class="line"><span class="keyword">if</span> (info == <span class="literal">null</span> || !info.isAvailable()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ConnectivityManager.TYPE_MOBILE == info.getType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能让wifi环境下也返回是3G&#x2F;4G网络就可以达到目的了，但是直接修改上述代码是不行的，因为判断当前是否是3G&#x2F;4G网络的地方很多，一一修改比较耗时间，关键是项目中导入的很多SDK中也有网络类型的判断，SDK中的代码我们没法修改。</p><p>既然不能直接修改网络判断的代码，那能不能通过修改<code>ConnectivityManager</code>类（以下简称<code>CM</code>）的<code>getActiveNetworkInfo</code>方法的返回值，让wifi环境下<code>getActiveNetworkInfo</code>方法也返回3G&#x2F;4G网络的<code>NetworkInfo</code>呢？</p><p>听起来有些似乎有点困难。让我们先看看源代码，一步一步分析。</p><h3 id="2-分析源码，寻找切入点"><a href="#2-分析源码，寻找切入点" class="headerlink" title="2. 分析源码，寻找切入点"></a>2. 分析源码，寻找切入点</h3><p>从源码看起来<code>CM</code>类使用了单例模式，其<code>getActiveNetworkInfo</code>方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> NetworkInfo <span class="title function_">getActiveNetworkInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mService.getActiveNetworkInfo();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>mService</code>对象是<code>IConnectivityManager</code>接口（以下简称<code>ICM</code>）的一个实例，这个接口是一个aidl接口，不属于Android SDK的一部分，<a href="http://androidxref.com/5.0.0_r2/xref/frameworks/base/core/java/android/net/IConnectivityManager.aidl">源码</a>在framework中。如果能自己创建一个<code>ICM</code>对象替换调<code>CM</code>类中原本的<code>mService</code>属性，就可以实现修改<code>getActiveNetworkInfo</code>方法返回值的效果了。</p><h3 id="3-使用动态代理替换原有的mService对象"><a href="#3-使用动态代理替换原有的mService对象" class="headerlink" title="3. 使用动态代理替换原有的mService对象"></a>3. 使用动态代理替换原有的<code>mService</code>对象</h3><p><code>ICM</code>对AndroidSDK不可见，我们不能直接创建一个类并实现了<code>ICM</code>接口。另外这个接口声明了50个左右的方法，即使能创建实现了<code>ICM</code>接口的实例，要重写这50个左右的方法也不那么容易。那有没有其他简便的方法创建<code>ICM</code>实例呢？有，使用动态代理。</p><p>关于什么是动态代理，动态代理可以做什么，可以参考<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">这篇文章</a>，这里不再介绍（其实是技术太菜，说不清楚）。下面是使用动态代理替换<code>CM</code>中原有的<code>mService</code>属性的过程：</p><ol><li>使用反射获取原有的<code>mService</code>对象：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取ConnectivityManager对象</span></span><br><span class="line"><span class="type">ConnectivityManager</span> <span class="variable">cm</span> <span class="operator">=</span> (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line"><span class="comment">// 获取ConnectivityManager的mService对象</span></span><br><span class="line">Field[] fs = ConnectivityManager.class.getDeclaredFields();</span><br><span class="line"><span class="type">Object</span> <span class="variable">mService</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (fs != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Field f : fs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;mService&quot;</span>.equals(f.getName())) &#123;</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            mService = f.get(cm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用动态代理创建<code>ICM</code>对象，并修改 <code>getActiveNetworkInfo</code> 的返回值为自己准备好的<code>networkInfo</code>，其他方法仍然调用<code>mService</code>的相应方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">mFinalService</span> <span class="operator">=</span> mService;</span><br><span class="line"><span class="comment">// 使用动态代理创建 IConnectivityManager 的实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">mProxyService</span> <span class="operator">=</span> Proxy.newProxyInstance(ConnectivityManager.class.getClassLoader(),</span><br><span class="line">    <span class="comment">// 需要实现的接口</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Class.forName(<span class="string">&quot;android.net.IConnectivityManager&quot;</span>)&#125;,</span><br><span class="line">    <span class="comment">// 方法调用处理器</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="comment">// 拦截 getActiveNetworkInfo, 返回自己准备好的networkInfo</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;getActiveNetworkInfo&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (SettingsPreferences.getHookNetwork(context)) &#123;</span><br><span class="line">                    <span class="comment">// 该networkInfo是自己手动创建的3g模式的NetworkInfo。</span></span><br><span class="line">                    <span class="keyword">return</span> networkInfo;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不拦截其他方法，</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(mFinalService, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>将原来的<code>mService</code>对象替换为上一步中创建的<code>mProxyService</code>对象：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将自己创建的代理对象`mProxyService`替换调原来的`mService`对象。</span></span><br><span class="line"><span class="keyword">if</span> (fs != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Field f : fs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;mService&quot;</span>.equals(f.getName())) &#123;</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            f.set(cm, mProxyService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了修改<code>getActiveNetworkInfo</code>方法的返回值的目标，同时还能控制什么情况下返回自己定义的<code>NetworkInfo</code> (上述代码中只有当<code>SettingsPreferences.getHookNetwork(context)</code>为true的情况下才返回自己创建的networkInfo，否则仍然返回系统原本的networkInfo)。</p><blockquote><p>通过上述方式是不是能做到让代码中所有调用<code>getActiveNetworkInfo</code>方法的地方都返回自己创建的<code>NetworkInfo</code>呢？</p></blockquote><p>实践中发现：<code>CM</code>类看起来使用了单例模式，但事实上，在Api level 19 及以上的系统使用不同的<code>context</code>调用<code>getSystemService</code>方法返回的是不同的<code>CM</code>对象。</p><p>也就是说在代码中调用 <code>getSystemService</code>方法时用的<code>context</code>和上述代码中<code>context</code>不一样，那么获取到的<code>NetworkInfo</code>对象仍然可能是系统本身的<code>NetworkInfo</code>而不是我们自己创建的<code>NetworkInfo</code>。</p><h3 id="4-替换IConnectivityManager对象的创建过程"><a href="#4-替换IConnectivityManager对象的创建过程" class="headerlink" title="4. 替换IConnectivityManager对象的创建过程"></a>4. 替换<code>IConnectivityManager</code>对象的创建过程</h3><p>既然直接替换<code>mService</code>属性不完全可行，那能不能尝试找到<code>mService</code>被创建的地方，然后替换掉<code>mService</code>的创建过程，让所有给<code>mService</code>赋值的地方都返回我们自己创建的<code>ICM</code>对象呢？</p><blockquote><p>这个过程就好比现在小区内有好几家超市都在卖矿泉水，你想让这些超市都卖你自己生产的矿泉水，现在通过动态代理的方式你可以做到让其中一家超市卖你生产的矿泉水了。接下来你想让所有超市都卖你生产的矿泉水，如果能找到这些超市在哪家供应商进的货，然后通过某种方式，把供应商的货都替换为你生产的矿泉水那就ok了。</p></blockquote><p>来看看<code>mService</code>是何时以及怎么被创建的。</p><p>首先，<code>CM</code>是通过<code>Context</code>对象的<code>getSystemService</code>方法获取的。我们看看<code>getSystemService</code>方法是怎么实现的(<code>Context</code>的实现在<code>ContextImpl</code>里面)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSystemService</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">    <span class="keyword">return</span> fetcher != <span class="literal">null</span> ? fetcher.getService(ctx) : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出来，所有的service对象都保存在一张map(<code>SYSTEM_SERVICE_FETCHERS</code>)中，该map的初始化过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">registerService(Context.CONNECTIVITY_SERVICE, ConnectivityManager.class,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">StaticApplicationContextServiceFetcher</span>&lt;ConnectivityManager&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ConnectivityManager <span class="title function_">createService</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">            <span class="type">IBinder</span> <span class="variable">b</span> <span class="operator">=</span> ServiceManager.getService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">            <span class="type">IConnectivityManager</span> <span class="variable">service</span> <span class="operator">=</span> IConnectivityManager.Stub.asInterface(b);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConnectivityManager</span>(context, service);</span><br><span class="line">        &#125;&#125;);</span><br></pre></td></tr></table></figure><p>从上述代码看来，<code>ICM</code>的创建依赖于<code>ServiceManager.getService</code>方法返回的<code>IBinder</code>对象，使用这个<code>IBinder</code>对象再调用<code>IConnectivityManager.Stub</code>类的静态方法<code>asInterface</code>就可以将其转为本地接口<code>ICM</code>对象（这也使用<code>Binder</code>进行跨进程方法调用的基本流程）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.net.IConnectivityManager <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="literal">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> android.net.IConnectivityManager))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((android.net.IConnectivityManager) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">android</span>.net.IConnectivityManager.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结一下： <code>CM</code>的<code>getActiveNetworkInfo</code>方法直接调用了其成员变量<code>mService</code>的<code>getActiveNetworkInfo</code>方法，而<code>mService</code>是一个<code>ICM</code>的实例，它是在<code>CM</code>对象创建时被赋值的(构造函数中)。<code>CM</code>对象的创建位于<code>ContextImpl</code>类中，其创建时会首先调用<code>ServiceManager.getService</code>方法获取到一个<code>IBinder</code>对象，并通过<code>IConnectivityManager.Stub</code>的静态方法<code>asInterface</code>将这个<code>IBinder</code>对象转为<code>ICM</code>对象，最终以这个<code>ICM</code>对象作为参数创建了<code>CM</code>对象。</p></blockquote><p>找到<code>CM</code>以及<code>ICM</code>创建的地方后，目标就很明确了：只要自己创建一个<code>IBinder</code>对象替换掉<code>ServiceManager.getService</code>方法返回的<code>IBinder</code>对象，然后修改这个<code>IBinder</code>的<code>queryLocalInterface</code>方法让它始终返回同一个<code>ICM</code>对象就可以了。</p><p>要想替换掉<code>ServiceManager.getService</code>的返回值，我们先看看这个方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title function_">getService</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">service</span> <span class="operator">=</span> sCache.get(name);</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getIServiceManager().getService(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;error in getService&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中， <code>sCache</code>是<code>ServiceManager</code>的一个静态成员变量（<code>Map</code>类型），我们可以自己创建一个<code>IBinder</code>对象（跟之前一样，使用动态代理创建），然后通过<code>Map</code>的<code>put</code>方法将<code>sCache</code>里面的内容替换，从而达到瞒天过海的目的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先获取ServiceManager class</span></span><br><span class="line">Class&lt;?&gt; serviceManager = Class.forName(<span class="string">&quot;android.os.ServiceManager&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">getService</span> <span class="operator">=</span> serviceManager.getDeclaredMethod(<span class="string">&quot;getService&quot;</span>, String.class);</span><br><span class="line"><span class="comment">// 调用ServiceManag的&quot;getService&quot;方法获取原始的 IBinder 对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">rawBinder</span> <span class="operator">=</span> (IBinder) getService.invoke(<span class="literal">null</span>, Context.CONNECTIVITY_SERVICE);</span><br><span class="line"><span class="comment">// 使用动态代理伪造一个新的 IBinder对象</span></span><br><span class="line"><span class="type">IBinder</span> <span class="variable">hookedBinder</span> <span class="operator">=</span> (IBinder) newProxyInstance(serviceManager.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;IBinder.class&#125;, <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// ....</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// 把伪造的 IBinder 对象放进ServiceManager的cache里面</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">cacheField</span> <span class="operator">=</span> serviceManager.getDeclaredField(<span class="string">&quot;sCache&quot;</span>);</span><br><span class="line">cacheField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">Map&lt;String, IBinder&gt; cache = (Map&lt;String, IBinder&gt;) cacheField.get(<span class="literal">null</span>);</span><br><span class="line">cache.put(Context.CONNECTIVITY_SERVICE, hookedBinder);</span><br></pre></td></tr></table></figure><p>替换掉<code>ServiceManager.getService</code>的返回值以后，接着我们需要修改我们刚刚创建的<code>IBinder</code>对象的<code>queryLocalInterface</code>方法，让它始终返回同一个<code>ICM</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">mIConnectivityManager</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取原本的IConnectivityManager对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">getBaseManager</span><span class="params">(<span class="meta">@NonNull</span> IBinder binder, Class&lt;?&gt; stubCls)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">asInterfaceMethod</span> <span class="operator">=</span> stubCls.getDeclaredMethod(<span class="string">&quot;asInterface&quot;</span>, IBinder.class);</span><br><span class="line">            <span class="keyword">return</span> asInterfaceMethod.invoke(<span class="literal">null</span>, binder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LogUtils.error(<span class="string">&quot;wentaoli hook =&gt; createIConnectivityManager error: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;queryLocalInterface&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(baseBinder, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIConnectivityManager != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mIConnectivityManager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换掉 queryLocalInterface 方法的返回值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">base</span> <span class="operator">=</span> getBaseManager(baseBinder, Class.forName(<span class="string">&quot;android.net.IConnectivityManager$Stub&quot;</span>));</span><br><span class="line">        mIConnectivityManager = Proxy.newProxyInstance(proxy.getClass().getClassLoader(),</span><br><span class="line">                <span class="comment">// asInterface 的时候会检测是否是特定类型的接口然后进行强制转换, 因此这里的动态代理生成的类型信息的类型必须是正确的</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;IInterface.class, Class.forName(<span class="string">&quot;android.net.IConnectivityManager&quot;</span>)&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BinderHookHandler</span>(context, base));</span><br><span class="line">        <span class="keyword">return</span> mIConnectivityManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BinderHookHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Context context;</span><br><span class="line">    <span class="comment">// 原始的IConnectivityManager对象 (也是IInterface)</span></span><br><span class="line">    Object base;</span><br><span class="line">    BinderHookHandler(Context context, Object base) &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context.getApplicationContext();</span><br><span class="line">        <span class="built_in">this</span>.base = base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;getActiveNetworkInfo&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (SettingsPreferences.getHookNetwork(context)) &#123;</span><br><span class="line">                <span class="keyword">return</span> networkInfo;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(base, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成。</p><h3 id="5-模拟发送网络变化广播"><a href="#5-模拟发送网络变化广播" class="headerlink" title="5. 模拟发送网络变化广播"></a>5. 模拟发送网络变化广播</h3><p>经过上面操作，已经可以做到在wifi环境下模拟移动网络了，但还有一些可以完善的地方，比如说网络的切换。</p><p>考虑如下情况：当在应用中通过手动点击某个按钮将上述<code>SettingsPreferences.getHookNetwork(context)</code>的值从<code>false</code>变为<code>true</code>，这时候<code>getActiveNetworkInfo</code>方法返回的<code>NetworkInfo</code>就从原来的wifi变成了自定义的3g&#x2F;4g网络，这事实上就相当于发生了一次网络状态的变化。按照正常的流程，如果手机发生网络状态变化系统会发送相应的广播，同时app中动态或者静态注册的广播接收器会收到相应的广播。但是现在我们只是模拟网络变化，系统自然不会帮忙发送网络状态变化广播，那怎么去模拟这个过程呢？</p><p>网络状态变化广播是一个敏感的广播，需要系统级权限才能发送，普通应用是不允许发送的。既然不能直接发送这个广播，那能不能通过获取到当前应用中所注册的广播接收器，然后直接调用这些广播接收器的<code>onReceive</code>方法来模拟广播接收过程呢？让我们来分析下。</p><p>首先来看静态注册的广播接收器。</p><h4 id="5-1-静态注册的广播接收器"><a href="#5-1-静态注册的广播接收器" class="headerlink" title="5.1.  静态注册的广播接收器"></a>5.1.  静态注册的广播接收器</h4><p>要获取当前app中的注册了哪些静态广播接收器是比较简单的，就跟获取app中声明了哪些<code>Activity</code>是一样的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class="line">i.setPackage(context.getPackageName());</span><br><span class="line">List&lt;ResolveInfo&gt; list = context.getPackageManager().queryBroadcastReceivers(i, PackageManager.MATCH_ALL);     </span><br></pre></td></tr></table></figure><p>通过上述代码拿到能接收网络状态变化的静态广播接收器后（当然并不是<code>BroadcastReceiver</code>实例对象，仅仅是一些<code>BroadcastReceiver</code>描述信息），只需遍历这些接收器信息，然后通过<code>Class.newInstance</code>方法创建相应的<code>BroadcastReceiver</code>实例，再调用其<code>onReceive</code>方法就行了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ResolveInfo resolveInfo : list) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(resolveInfo.activityInfo.name);</span><br><span class="line">        <span class="type">BroadcastReceiver</span> <span class="variable">receiver</span> <span class="operator">=</span> (BroadcastReceiver) clazz.newInstance();</span><br><span class="line">        receiver.onReceive(context, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LogUtils.error(<span class="string">&quot;wentaoli hook static receiver error &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了模拟静态注册的广播接收器收到广播的场景。</p><p>下面再看动态注册的广播接收器</p><h4 id="5-2-动态注册的广播接收器"><a href="#5-2-动态注册的广播接收器" class="headerlink" title="5.2.  动态注册的广播接收器"></a>5.2.  动态注册的广播接收器</h4><p>要获得应用中所有动态注册的广播接收器并不容易。通过对广播注册与接收的源代码的分析得知(关于广播的注册接收过程可以参考<a href="http://weishu.me/2016/04/12/understand-plugin-framework-receiver/">这篇博客</a>)，广播的接收过程最终会走到<code>LoadedApk</code>的一个内部类 <code>ReceiverDispatcher</code>的<code>performReceive</code>方法中，而<code>LoadedApk</code>的一个成员变量<code>mReceivers</code>则保存了当前app中所有动态注册的广播接收器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Context, HashMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;&gt; mReceivers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Context, HashMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;&gt;();</span><br></pre></td></tr></table></figure><p>只要能拿到<code>LoadedApk</code>实例的<code>mReceviers</code>属性值，则可以获取到所有动态注册的广播。要获取<code>LoadedApk</code>的<code>mReceivers</code>属性值，首先得拿到<code>LoadedApk</code>的实例。事实上，<code>ActivityThread</code> 的<code>mPackages</code>属性就持有<code>LoadedApk</code>的实例(看过四大组件启动流程源代码的同学应该对<code>ActivityThread</code>类很熟悉)，接着获取<code>LoadedApk</code>以及<code>LoadedApk</code>的<code>mReceivers</code>属性就都不是问题了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取到当前应用的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">&quot;android.app.ActivityThread&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">currentActivityThreadMethod</span> <span class="operator">=</span> activityThreadClass.getDeclaredMethod(<span class="string">&quot;currentActivityThread&quot;</span>);</span><br><span class="line">currentActivityThreadMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">currentActivityThread</span> <span class="operator">=</span> currentActivityThreadMethod.invoke(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 获取mPackages属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> activityThreadClass.getDeclaredField(<span class="string">&quot;mPackages&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> (Map) f.get(currentActivityThread);</span><br><span class="line"><span class="comment">// 获取LoadedApk实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">loadedApkRef</span> <span class="operator">=</span> map.get(context.getPackageName());</span><br><span class="line"><span class="keyword">if</span> (loadedApkRef <span class="keyword">instanceof</span> WeakReference) &#123;</span><br><span class="line">     <span class="type">Object</span> <span class="variable">loadedApk</span> <span class="operator">=</span> ((WeakReference) loadedApkRef).get();</span><br><span class="line">     <span class="comment">// 获取LoadedApk实例的mReceivers属性值</span></span><br><span class="line">     field = loadedApk.getClass().getDeclaredField(<span class="string">&quot;mReceivers&quot;</span>);</span><br><span class="line">     field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">     <span class="type">Map</span> <span class="variable">mReceiversMap</span> <span class="operator">=</span> (Map) field.get(loadedApk);</span><br><span class="line">     <span class="comment">// 通过mReceivers属性获取所有动态注册的广播</span></span><br><span class="line">     ....</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在获取到所有动态注册的广播接收器后，只要知道哪些广播接收器可以接收网络状态变化广播，然后再直接调用这些广播接收器的<code>onReceive</code>方法就好了。但事实上这并不容易，具体怎么判断哪些广播接收器可以接收网络状态变化广播，就不再说明了（其实是懒），有兴趣的可以到<a href="https://gist.github.com/likebamboo/83b51fa9446c9ac04131c5798094973e">这里</a>查看代码。</p><p>到此为止就完成了对发送网络状态变化广播的模拟，也就完成了Wifi下模拟3g&#x2F;4g网络的整个流程的模拟。</p><h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h3><ol><li><p>关于动态代理：<br>动态代理是<code>AOP</code>的基础。像 <a href="https://github.com/DroidPluginTeam/DroidPlugin">DroidPlugin</a> 之类插件框架以动态代理作为基础的。</p></li><li><p>关于兼容性：<br>文中的代码中使用了较多的反射调用以及系统隐藏的api，由于公司没有那么多手机，没有测试代码的兼容性。</p></li></ol><h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><blockquote><p><a href="http://weishu.me/2016/04/12/understand-plugin-framework-receiver/">http://weishu.me/2016/04/12/understand-plugin-framework-receiver/</a><br><a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/</a><br><a href="http://blog.csdn.net/u013263323/article/details/76014494">http://blog.csdn.net/u013263323/article/details/76014494</a><br><a href="http://blog.csdn.net/Luoshengyang/article/details/6744448">http://blog.csdn.net/Luoshengyang/article/details/6744448</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍如果让手机在wifi网络下(不插sim卡)模拟3g&amp;#x2F;4g网络，以方便调试应用。&lt;/p&gt;</summary>
    
    
    
    <category term="android" scheme="https://www.likebamboo.com/categories/android/"/>
    
    
    <category term="android" scheme="https://www.likebamboo.com/tags/android/"/>
    
    <category term="动态代理" scheme="https://www.likebamboo.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    <category term="hook" scheme="https://www.likebamboo.com/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>Android 主题切换实现方案探索</title>
    <link href="https://www.likebamboo.com/2016/05/22/android-theme-switch/"/>
    <id>https://www.likebamboo.com/2016/05/22/android-theme-switch/</id>
    <published>2016-05-21T16:00:00.000Z</published>
    <updated>2025-10-29T12:10:40.741Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h3 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h3><p>很多应用都有更换主题的需求：新闻、阅读类应用通常需要支持白天、夜间模式切换，以便在不同时间都能提供良好的阅读体验；电商类应用需要在节假日、促销活动期间提供相应的主题以烘托活动气氛；社交娱乐类应用需要支持用户自行设置主题以满足用户个性化需要。本文将探索Android APP主题切换功能的各种实现方案，并结合聚力视频APP主题切换功能的实现过程，总结各个方案的优缺点以及适应场景。</p><h3 id="0x01-使用App内置style实现主题更换"><a href="#0x01-使用App内置style实现主题更换" class="headerlink" title="0x01 使用App内置style实现主题更换"></a>0x01 使用App内置style实现主题更换</h3><p>Android 原生支持通过<code>setTheme</code>方法为任一界面单独设置主题样式。要通过这种方式实现多主题，首先需要为那些支持主题切换的元素（控件）定义相应的属性。然后在不同的主题<code>style</code>中为这些属性赋不同的值。接下来在布局文件中通过<code>?attr/**</code>的形式设置控件的属性值。最终在<code>Activity</code>中通过<code>setTheme</code>方法（该方法需要在<code>setContentView</code>方法之前调用）为当前界面设置主题。</p><p>当更换主题时可以<code>finish</code>当前界面，然后改变主题使用的<code>style</code>的值，并重新启动当前界面，这时候就可以完成主题替换。</p><p>改变主题时重启当前界面对用户来说不是一个好的体验，可以通过记录当前界面需要支持主题切换的控件，在切换主题时直接为这些控件设置新的属性值来规避这个问题。</p><p>图1-1是一个示例程序的运行效果：</p><p><img src="http://120.24.93.248/images/pptv/theme-switch-style.gif" alt="图1-1"></p><blockquote><p>示例程序源码： <a href="https://github.com/likebamboo/ThemeSwitch/tree/style">https://github.com/likebamboo/ThemeSwitch/tree/style</a></p></blockquote><p>通过App内置的多个style实现主题切换小结：</p><table><thead><tr><th align="left">优点</th><th align="left">简单，容易实现；Android 原生支持</th></tr></thead><tbody><tr><td align="left">缺点</td><td align="left">主题资源只能内置，不能动态增删主题，增加了安装包的大小；必须由用户主动切换主题</td></tr><tr><td align="left">适用场景</td><td align="left">白天模式、夜间模式切换</td></tr><tr><td align="left">典型APP</td><td align="left">网易新闻、QQ浏览器、哔哩哔哩动画</td></tr></tbody></table><h3 id="0x02-通过普通zip主题包实现主题切换"><a href="#0x02-通过普通zip主题包实现主题切换" class="headerlink" title="0x02 通过普通zip主题包实现主题切换"></a>0x02 通过普通zip主题包实现主题切换</h3><p>通过加载不同的zip主题包实现主题切换，首先需要将配置文件、资源文件打包压缩为zip主题包。然后在APP中内置或在适当的时候下载该主题包。在切换主题的时候通过解析配置文件加载zip包中的资源，实时为相应控件设置新的属性值。这样便可以实现主题切换。</p><p>需要注意的是，如果主题包比较大，解析、加载其中的资源文件将会是一个耗时的过程，有必要放在一个独立的线程中。另外，可能需要为不同分辨率的设备提供不同尺寸的主题包，防止低分辨率的手机在加载主题资源时出现内存溢出（<code>OOM</code>）的问题。</p><p>图2-1是一个示例程序的运行效果：</p><p><img src="http://120.24.93.248/images/pptv/theme-switch-zip.gif" alt="图2-1"></p><blockquote><p>示例程序源码： <a href="https://github.com/likebamboo/ThemeSwitch/tree/zip">https://github.com/likebamboo/ThemeSwitch/tree/zip</a></p></blockquote><p>通过普通zip主题包实现主题切换小结：</p><table><thead><tr><th align="left">优点</th><th align="left">可扩展行高，支持主题包动态下载并由后端控制主题切换时机</th></tr></thead><tbody><tr><td align="left">缺点</td><td align="left">需要自己解析zip包中的资源文件；针对不同手机分辨率可能需要多个zip主题包</td></tr><tr><td align="left">适用场景</td><td align="left">少量控件的颜色或图标切换</td></tr><tr><td align="left">典型APP</td><td align="left">暂时未发现</td></tr></tbody></table><h3 id="0x03-动态加载apk主题包实现主题切换"><a href="#0x03-动态加载apk主题包实现主题切换" class="headerlink" title="0x03 动态加载apk主题包实现主题切换"></a>0x03 动态加载apk主题包实现主题切换</h3><p>方案2虽然可以实现动态的主题切换，也方便制作多套主题。但是，需要在程序中自己实现查找、解析资源的过程，切换主题耗时比较长。</p><p>如果可以像使用APP内部资源一样直接通过资源id或描述符使用主题包资源，就省去了查找、解析资源的过程。调研发现，Android的资源查找、管理离不开<code>AssetManager</code>和<code>Resources</code>这两个类，APP资源的管理实际是由这两个类实现的。其中<code>Resources</code>类可以根据id来查找资源，<code>AssetManager</code>类根据文件名来查找资源。如图3-1</p><p><img src="http://120.24.93.248/images/pptv/theme-switch-resources.png" alt="图3-1 来源于：http:&#x2F;&#x2F;blog.csdn.net&#x2F;beyond702&#x2F;article&#x2F;details&#x2F;49228115"></p><p>而<code>AssetManager</code>恰巧可以通过<code>addAssetPath</code>方法实现对非APP内部的其他资源的管理。<br>因此，为了实现使用id或资源描述符来查找主题包中的资源，我们需要将主题资源编译打包成一个apk文件。然后，创建一个独立的<code>AssetManager</code>和<code>Resources</code>对象用于管理主题包中的资源。代码如图3-2</p><p><img src="http://120.24.93.248/images/pptv/theme-switch-get-resources.png" alt="图3-2"></p><p>需要注意的是，<code>addAssetPath</code>方法是Android隐藏的API，所以需要通过反射的方式调用。另外主题包中的资源id和APP内部的资源id不可能完全一样，所以使用APP内部的资源id去主题apk包中查找资源会出现找不到或找不准的情况，这时候可以通过APP内部的资源名去主题包中查找对应的资源。</p><p>有了管理主题资源的<code>Resources</code>对象，在切换主题时，只要通过<code>Resources</code>对象从apk主题包中获取主题资源，并为对应的支持主题切换的控件设置相应的属性值即可。</p><p>图3-3是一个示例程序的运行效果：</p><p><img src="http://120.24.93.248/images/pptv/theme-switch-apk.gif" alt="图3-3"></p><blockquote><p>示例程序源码： <a href="https://github.com/likebamboo/ThemeSwitch/tree/apk">https://github.com/likebamboo/ThemeSwitch/tree/apk</a></p></blockquote><p>通过apk主题包实现主题切换小结：</p><table><thead><tr><th align="left">优点</th><th align="left">针对不同手机分辨率可以加载最合适的皮肤资源，无需多个主题包；支持主题包动态下载并由后端控制主题切换时机</th></tr></thead><tbody><tr><td align="left">缺点</td><td align="left">实现起来相对困难，容易出错；主题包太大时会对程序性能有一定影响</td></tr><tr><td align="left">适用场景</td><td align="left">少量控件的颜色或图标切换</td></tr><tr><td align="left">典型APP</td><td align="left">聚力视频、爱奇艺</td></tr></tbody></table><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>以上就是主题切换功能常见的几种实现方案，聚力视频APP目前采用最后一种。也许还有其他的实现方案。但这些实现方案中很难说哪种最好，毕竟就技术而言，常常只有最适合的方案，而没有最好的方案。</p><blockquote><p>参考文章 :<br><a href="https://blog.stylingandroid.com/prism-fundamentals-part-1/">https://blog.stylingandroid.com/prism-fundamentals-part-1/</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将探索Android APP主题切换功能的各种实现方案，并通过实例总结出各个方案的优缺点以及适应场景。&lt;/p&gt;</summary>
    
    
    
    <category term="android" scheme="https://www.likebamboo.com/categories/android/"/>
    
    
    <category term="android" scheme="https://www.likebamboo.com/tags/android/"/>
    
    <category term="主题切换" scheme="https://www.likebamboo.com/tags/%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>【译】Android Studio 使用技巧系列(六)</title>
    <link href="https://www.likebamboo.com/2015/09/29/android-studio-tips-6/"/>
    <id>https://www.likebamboo.com/2015/09/29/android-studio-tips-6/</id>
    <published>2015-09-29T10:00:00.000Z</published>
    <updated>2025-10-29T12:10:40.737Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><blockquote><p>原文:<a href="http://www.developerphil.com/android-studio-tips-of-the-day-roundup-6/">http://www.developerphil.com/android-studio-tips-of-the-day-roundup-6/</a></p></blockquote><h3 id="50-重构"><a href="#50-重构" class="headerlink" title="50.  重构"></a>50.  重构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： ctrl + t</span><br><span class="line">Windows / Linux: ctrl + shift + alt + t</span><br></pre></td></tr></table></figure><p>这是一个针对当前选择的代码显示上下文所有可用的重构的快捷键。这个列表可以通过键盘进行检索并且你也可以使用左侧的数字进行快速访问。</p><p><img src="/.com//50.png" alt="Alt text"></p><h3 id="51-最近修改文件"><a href="#51-最近修改文件" class="headerlink" title="51.  最近修改文件"></a>51.  最近修改文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： cmd + shift + e</span><br><span class="line">Windows / Linux: ctrl + shift + e</span><br></pre></td></tr></table></figure><p>这个和<code>Recents</code>弹出框有所不同，这个列出是在本地最近被修改的文件。它是按修改的顺序进行存储（最上面是最近被编辑的）。更方便的是你可以输入字符进行过滤列表。<br><img src="/.com//51.gif" alt="Alt text"></p><h3 id="52-相关文件"><a href="#52-相关文件" class="headerlink" title="52.  相关文件"></a>52.  相关文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： cmd + ctrl + up</span><br><span class="line">Windows / Linux: ctrl + alt + home</span><br></pre></td></tr></table></figure><p>它可以帮助你很轻松地在布局和<code>Activity/fragment</code>之间进行切换。还有一个快捷方式是在类名的旁边和布局文件的顶部。。<br><img src="/.com//52.gif" alt="Alt text"></p><h3 id="53-提取变量"><a href="#53-提取变量" class="headerlink" title="53.  提取变量"></a>53.  提取变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： cmd + alt + v</span><br><span class="line">Windows / Linux: ctrl + alt + v</span><br></pre></td></tr></table></figure><p>它是一个可以不通过重构菜单就自动提取变量的快捷键。<br>当你动态生成代码时你可以不用输入变量的声明就可以直接生成变量名称。IDE将会生成声明并且还会给出一些建议的变量名称。</p><p><strong>相关技巧：</strong></p><blockquote><p>如果你想修改声明类型为一些更通用的（如：<code>List</code>而不是<code>ArrayList</code>）,你可以使用<code>Shift+Tab</code>它会给出一个可用类型的列表。</p></blockquote><p><img src="/.com//53.gif" alt="Alt text"></p><h3 id="54-提取参数"><a href="#54-提取参数" class="headerlink" title="54.  提取参数"></a>54.  提取参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： cmd + alt + p</span><br><span class="line">Windows / Linux: ctrl + alt + p</span><br></pre></td></tr></table></figure><p>它是一个可以不通过重构菜单就自动提取参数的快捷键。<br>当你意识到一个方法可能是通用的时候，可以通过提取一部分做为一个参数。它会使用当前值作为一个参数然后复制原先的值作为调用者的参数。<br><img src="/.com//54.gif" alt="Alt text"></p><h3 id="55-提取方法"><a href="#55-提取方法" class="headerlink" title="55.  提取方法"></a>55.  提取方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： cmd + alt + m</span><br><span class="line">Windows / Linux: ctrl + alt + m</span><br></pre></td></tr></table></figure><p>跟着我提取的思路进行重构，这个操作可以提取一个代码块做为一个新的方法。<br>这个功能是相当有用的。无论什么时候，当你遇到一个变得有点复杂的方法的时候，你可以使用这个操作安全地抽取一部分代码生成一个单独的方法。我所说的安全是因为IDE不会像我们可能会犯一个愚蠢的复制粘贴错误。</p><blockquote><p><strong>译者注：</strong> Eclipse中该操作的快捷键是 <code> alt + shift + m</code></p></blockquote><p><img src="/.com//55.gif" alt="Alt text"></p><h3 id="56-Inline"><a href="#56-Inline" class="headerlink" title="56.  Inline"></a>56.  Inline</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： cmd + alt + n</span><br><span class="line">Windows / Linux: ctrl + alt + n</span><br></pre></td></tr></table></figure><p>你使用提取有一点疯狂并且现在有太多的东西？你可以使用反向操作，它叫做<code>inline</code>。<br>它可以作用于方法，<code>Fields</code>，参数和变量。<br><img src="/.com//56.gif" alt="Alt text"></p><h3 id="57-重命名"><a href="#57-重命名" class="headerlink" title="57.  重命名"></a>57.  重命名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： shift + f6</span><br><span class="line">Windows / Linux: shift + f6</span><br></pre></td></tr></table></figure><p>使用这个，你可以将一个变量，field，方法，类和甚至是包重命名。<br>当然了，它会确保重命名在你整个应用的上下文中是有意义的，它不会简单地做一个查找然后替换所有文件！<br><img src="/.com//57.gif" alt="Alt text"></p><blockquote><p><strong>译者注：</strong> Eclipse中该操作的快捷键是 <code> alt + shift + r</code></p></blockquote><h3 id="58-Pull-Up-Push-Down"><a href="#58-Pull-Up-Push-Down" class="headerlink" title="58. Pull Up &#x2F; Push Down"></a>58. Pull Up &#x2F; Push Down</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： ctrl + t 然后选择成员 </span><br><span class="line">Windows / Linux: ctrl + alt + shift + t 然后选择成员 </span><br></pre></td></tr></table></figure><p>这里指的上拉成员的意思是我们将当前类的一些成员（通常是方法或属性）发送它到父类或接口。<br>如果继承于一个类，内容会被移动。如果是实现的一个接口，它将会声明方法作为接口的一部分，在你的类中保持原有的方法并且添加<code>@Override</code>注解。<br>这里指的下推成员，这正好是反向操作，我们会从父类或接口发送一些成员到子类。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Android Studio&lt;/code&gt;中快捷键使用技巧六&lt;/p&gt;</summary>
    
    
    
    <category term="android" scheme="https://www.likebamboo.com/categories/android/"/>
    
    
    <category term="androidstuido" scheme="https://www.likebamboo.com/tags/androidstuido/"/>
    
  </entry>
  
  <entry>
    <title>【译】Android Studio 使用技巧系列(五)</title>
    <link href="https://www.likebamboo.com/2015/09/29/android-studio-tips-5/"/>
    <id>https://www.likebamboo.com/2015/09/29/android-studio-tips-5/</id>
    <published>2015-09-29T09:00:00.000Z</published>
    <updated>2025-10-29T12:10:40.732Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><blockquote><p>原文:<a href="http://www.developerphil.com/android-studio-tips-of-the-day-roundup-5/">http://www.developerphil.com/android-studio-tips-of-the-day-roundup-5/</a></p></blockquote><h3 id="41-代码自动补全-Enter-与-Tab-比较"><a href="#41-代码自动补全-Enter-与-Tab-比较" class="headerlink" title="41.  代码自动补全 Enter  与 Tab 比较"></a>41.  代码自动补全 Enter  与 Tab 比较</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enter or tab</span><br></pre></td></tr></table></figure><p>你可以用<code>Enter</code>或<code>Tab</code>来实现代码自动补全并且它们之间有一个有趣的差异。<br>使用<code>Enter</code>将会自动完成你想要的语句。使用<code>Tab</code>将会自动完成语句并且向前删除所有代码直到下一个点号，括号，分号或空格。(译者注：看下图就明白了)<br><img src="/.com//41.gif" alt="Alt text"></p><h3 id="42-导航到父类"><a href="#42-导航到父类" class="headerlink" title="42.  导航到父类"></a>42.  导航到父类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： cmd + u</span><br><span class="line">Windows / Linux: ctrl + u</span><br></pre></td></tr></table></figure><p>如果你的光标在重写父类的一个方法内（如：<code>Activity#onCreate()</code>），这个将会跳到父类的实现上。<br>如果你的光标在类名上，它将会跳到父类。</p><p><img src="/.com//42.gif" alt="Alt text"></p><h3 id="43-返回到编辑器"><a href="#43-返回到编辑器" class="headerlink" title="43.  返回到编辑器"></a>43.  返回到编辑器</h3><p>有很多快捷键使光标离开编辑器（<code>type hierarchy</code>,<code>find usages</code>等）<br>如果你想退回到编辑器，你可以选择如下操作：</p><blockquote><p><code>Escape</code> :  简单地返回到编辑器。<br><code>Shift+Escape</code> :  关闭当前面板然后使光标返回到编辑器。</p></blockquote><p><img src="/.com//43.gif" alt="Alt text"></p><h3 id="44-跳到最近使用的工具窗口"><a href="#44-跳到最近使用的工具窗口" class="headerlink" title="44.  跳到最近使用的工具窗口"></a>44.  跳到最近使用的工具窗口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mac ： f12 </span><br><span class="line">Windows / Linux: f12 </span><br><span class="line">可能和操作系统的快捷键有冲突</span><br></pre></td></tr></table></figure><p>有时候，你从面板返回到编辑器，但是你发现不得不再返回到这个面板。例如：浏览<code>find usages</code>。使用这个快捷键，你可以不用鼠标返回到这个面板。<br><img src="/.com//44.gif" alt="Alt text"></p><h3 id="45-隐藏所有面板"><a href="#45-隐藏所有面板" class="headerlink" title="45.  隐藏所有面板"></a>45.  隐藏所有面板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： cmd + shift + f12 </span><br><span class="line">Windows / Linux: ctrl + shift + f12 </span><br></pre></td></tr></table></figure><p>让编辑器进入某种形式上的全屏模式。再次调用这个快捷键可以返回所有面板到它们之前的状态。<br><img src="/.com//45.gif" alt="Alt text"></p><h3 id="46-通过编号打开面板"><a href="#46-通过编号打开面板" class="headerlink" title="46.  通过编号打开面板"></a>46.  通过编号打开面板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： cmd + number</span><br><span class="line">Windows / Linux: alt + number</span><br></pre></td></tr></table></figure><p>你可能注意到一些面板名字左边有一个数字。这是打开它们的快捷键。<br>如果你看不到面板的名字，可以点击IDE的左下角的盒子似的东西。<br><img src="/.com//46.gif" alt="Alt text"></p><h3 id="47-显示参数信息"><a href="#47-显示参数信息" class="headerlink" title="47.  显示参数信息"></a>47.  显示参数信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： cmd + p</span><br><span class="line">Windows / Linux: ctrl + p</span><br></pre></td></tr></table></figure><p>当你正调用一个方法时会显示一个方法参数的列表。这在你想看已存在的方法参数时是挺有用的。<br>你光标所在位置的参数会用黄色显示。如果没有参数用黄色，这意味着方法调用是无效的，可能有参数不能被正确地强转（如：将一个<code>float</code>值传给一个<code>int</code>类型的参数）<br>当你正在写一个方法调用参数信息意外地消失了，就像我经常做的，你也可以输入一个逗号（<code>,</code><br>）用来触发参数信息的显示。<br><img src="/.com//47.gif" alt="Alt text"></p><h3 id="48-切换器"><a href="#48-切换器" class="headerlink" title="48.  切换器"></a>48.  切换器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： ctrl + tab</span><br><span class="line">Windows / Linux: ctrl + tab</span><br></pre></td></tr></table></figure><p>这个功能和<code>IDE</code>的<code>alt + tab</code> &#x2F; <code>cmd + tab</code>差不多。它允许你导航到一个<code>tab</code>或一个<code>panel</code>。<br>一旦它被打开，只要你按住<code>ctrl</code>键，你可以使用数字或字母快捷键快速导航。你也可以通过按下<code>backspace</code>键关闭一个已选择的<code>tab</code>或<code>panel</code>。<br><img src="/.com//48.gif" alt="Alt text"></p><h3 id="49-上下文信息"><a href="#49-上下文信息" class="headerlink" title="49.  上下文信息"></a>49.  上下文信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac ： ctrl + shift + q</span><br><span class="line">Windows / Linux: ctrl + shift + q</span><br></pre></td></tr></table></figure><p>这个将会显示你当前位置，当你的定义范围超出滚动的区域时。通常，这将会是类或内部类的名称，但它也可能是当前方法名。<br>在我看来，它最好的作用是快速查看当前类继承或实现关系。<br>它也可以在xml文件中使用。<br><img src="/.com//49.gif" alt="Alt text"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Android Studio&lt;/code&gt;中快捷键使用技巧五&lt;/p&gt;</summary>
    
    
    
    <category term="android" scheme="https://www.likebamboo.com/categories/android/"/>
    
    
    <category term="androidstuido" scheme="https://www.likebamboo.com/tags/androidstuido/"/>
    
  </entry>
  
  <entry>
    <title>【译】Android Studio 使用技巧系列(四)</title>
    <link href="https://www.likebamboo.com/2015/09/29/android-studio-tips-4/"/>
    <id>https://www.likebamboo.com/2015/09/29/android-studio-tips-4/</id>
    <published>2015-09-29T08:00:00.000Z</published>
    <updated>2025-10-29T12:10:40.726Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><blockquote><p>原文:<a href="http://www.developerphil.com/android-studio-tips-of-the-day-roundup-4/">http://www.developerphil.com/android-studio-tips-of-the-day-roundup-4/</a></p></blockquote><h3 id="32-分析数据流"><a href="#32-分析数据流" class="headerlink" title="32.  分析数据流"></a>32.  分析数据流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">菜单 : `Analyze -&gt; Analyze Data Flow to Here`</span><br><span class="line">Action 查找: `Analyze Data Flow to Here`</span><br></pre></td></tr></table></figure><p>这个可以查看当前变量、参数或<code>field</code>调用的路径！当你进入到一个你不熟悉的代码而又想理解这个参数是怎样传到那里的时候，这个操作就非常又有用了。<br>该操作也有一个反向操作<code>Analyze Data Flow </code><strong><code>from</code></strong><code> Here</code>，它将会显示变量、<code>field</code>或返回类型的被调用的路径。</p><p><img src="/.com//32.gif" alt="Alt text"></p><h3 id="33-文本多选"><a href="#33-文本多选" class="headerlink" title="33.  文本多选"></a>33.  文本多选</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : ctrl + g</span><br><span class="line">Windows / Linux : alt + j</span><br></pre></td></tr></table></figure><p>这是一个格外棒的功能！<br>当选中当前选择部分后，它会同时选中下一个出现代码的地方并且添加一个光标。这就意味着你可以在同一个文件中拥有有多个光标！你编辑的任何内容会在每个光标处都相同地执行一遍。<br><img src="/.com//33.gif" alt="Alt text"></p><h3 id="34-按列选择"><a href="#34-按列选择" class="headerlink" title="34.  按列选择"></a>34.  按列选择</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mouse: alt + 拖动鼠标</span><br><span class="line">Mac : cmd + shift + 8</span><br><span class="line">Windows / Linux : shift + alt + insert</span><br></pre></td></tr></table></figure><p>列选择，也被称为块选择。基本上，如果你向下移动光标，它将直接向下选择而不会很烦人地选择到行尾。<br>该操作同样会在块选择的每行后面放置一个光标。</p><blockquote><p><strong>译者注：</strong>  在Eclipse 中一直没找到该功能，不知道是不是我孤陋寡闻，平时只要涉及到按列选择，都是使用 notepad++ 完成的。</p></blockquote><p><img src="/.com//34.gif" alt="Alt text"></p><h3 id="35-后缀补全"><a href="#35-后缀补全" class="headerlink" title="35.  后缀补全"></a>35.  后缀补全</h3><p>这个不是特别的直观但功能依然很强大。该操作简化了用其它的东西包裹当前代码的操作，而不必大量的敲击键盘。<br>例如：为了实现对一个列表的迭代，你可以使用<code>myList.for</code>, 然后按下<code>Tab</code>键，它将会给你生成一个<code>for</code>循环。<br>一些我个人非常喜欢的：</p><blockquote><p><code>.for</code> (用于生成 <code>for</code> 循环)<br><code>.format</code> (用<code>String.format()</code> 包裹一个 字符串)<br><code>.cast</code> (用一个强制类型转换包裹一个语句)</p></blockquote><p><img src="/.com//35.gif" alt="Alt text"></p><h3 id="36-与剪贴板的内容对比"><a href="#36-与剪贴板的内容对比" class="headerlink" title="36.  与剪贴板的内容对比"></a>36.  与剪贴板的内容对比</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mouse: 右击选中的部分 -&gt; 选择 `Compare With Clipboard`</span><br><span class="line">查找Action : `Compare With Clipboard`</span><br></pre></td></tr></table></figure><p>它可以让当前选择的部分和剪贴板的内容做一个<code>diff</code>。<br><img src="/.com//36.gif" alt="Alt text"></p><h3 id="37-终止任务"><a href="#37-终止任务" class="headerlink" title="37.  终止任务"></a>37.  终止任务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + f2</span><br><span class="line">Windows / Linux : ctrl + f2</span><br></pre></td></tr></table></figure><p>该操作会终止当前正在运行的任务或者显示一个可以终止的任务列表(当不止一个任务正在运行时)。<br>对于终止调试或终止构建非常有用.<br><img src="/.com//37.gif" alt="Alt text"></p><h3 id="38-显示执行点"><a href="#38-显示执行点" class="headerlink" title="38.  显示执行点"></a>38.  显示执行点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : alt + f10</span><br><span class="line">Windows / Linux : alt + f10</span><br></pre></td></tr></table></figure><p>当正在调试时，该操作会让光标返回到当前正在调试的地方。<br>通常用于如下情况：</p><ul><li>调试时程序在某个地方中断了</li><li>你开始在这个文件查看然后跳到了其它一些文件</li><li>调用这个快捷键可以返回到你正在一步一步地调试的地方</li></ul><p><img src="/.com//38.gif" alt="Alt text"></p><h3 id="39-弹出版本控制操作项"><a href="#39-弹出版本控制操作项" class="headerlink" title="39. 弹出版本控制操作项"></a>39. 弹出版本控制操作项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : ctrl + v</span><br><span class="line">Windows / Linux : alt + `</span><br></pre></td></tr></table></figure><p>该操作可以显示版本控制最频繁的操作选项。如果你的工程没在<code>git</code>或其他版本控制系统管理下，它至少给你一个<code>Android Studio</code>维护的本地历史。<br><img src="/.com//39.gif" alt="Alt text"></p><h3 id="40-分支比较（Git）"><a href="#40-分支比较（Git）" class="headerlink" title="40. 分支比较（Git）"></a>40. 分支比较（Git）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">菜单 (for git): `VCS -&gt; Git -&gt; Compare With Branch`</span><br><span class="line">查找 Action: `Compare With Branch`</span><br></pre></td></tr></table></figure><p>假设你的工程在Git下，你可以将当前的文件或文件夹和别的分支比较。对于查看和你的主分支有多少不同时相当有用。<br><img src="/.com//40.gif" alt="Alt text"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Android Studio&lt;/code&gt;中快捷键使用技巧四&lt;/p&gt;</summary>
    
    
    
    <category term="android" scheme="https://www.likebamboo.com/categories/android/"/>
    
    
    <category term="androidstuido" scheme="https://www.likebamboo.com/tags/androidstuido/"/>
    
  </entry>
  
  <entry>
    <title>【译】Android Studio 使用技巧系列(三)-调试</title>
    <link href="https://www.likebamboo.com/2015/09/29/android-studio-tips-3/"/>
    <id>https://www.likebamboo.com/2015/09/29/android-studio-tips-3/</id>
    <published>2015-09-29T07:00:00.000Z</published>
    <updated>2025-10-29T12:10:40.718Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><blockquote><p>原文:<a href="http://www.developerphil.com/android-studio-tips-of-the-day-roundup-3/">http://www.developerphil.com/android-studio-tips-of-the-day-roundup-3/</a></p></blockquote><p>下面几个技巧是关于调试的。</p><h3 id="22-设置与取消断点"><a href="#22-设置与取消断点" class="headerlink" title="22.  设置与取消断点"></a>22.  设置与取消断点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + f8</span><br><span class="line">Windows / Linux : ctrl + f8</span><br></pre></td></tr></table></figure><p>我们从最简单的一个开始学习：添加一个断点。相信你已经调试过应用并且知道在左边框上通过鼠标左键单击设置或取消断点。如果不使用鼠标，你可用通过该快捷键设置断点。</p><blockquote><p><strong>译者注：</strong> Eclipse 中该操作快捷键是 <code>ctrl + shift + b</code> .</p></blockquote><p><img src="/.com//22.gif" alt="Alt text"></p><h3 id="23-条件断点"><a href="#23-条件断点" class="headerlink" title="23.   条件断点"></a>23.   条件断点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mouse : 在断点上右击，然后输入一个条件。 </span><br><span class="line">Mac : cmd + shift + f8 (光标在断点行) </span><br><span class="line">Windows / Linux : ctrl + shift + f8 (光标在断点行)</span><br></pre></td></tr></table></figure><p>简而言之，只有在某些条件下才打开断点。你可以输入任何基于当前范围返回一个<code>boolean</code>类型的<code>java</code>表达式。而且可喜的是是条件文本框支持代码自动补全。<br><img src="/.com//23.gif" alt="Alt text"></p><h3 id="24-日志断点"><a href="#24-日志断点" class="headerlink" title="24.  日志断点"></a>24.  日志断点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mouse : 在断点上右击，取消选中`Suspend`(暂停)，在`Log evaluated Expression`输入你的消息。</span><br></pre></td></tr></table></figure><p>这是一个输出日志信息但不会中断运行的断点。当你想打印一些东西但又不能或不想添加打印日志的代码时该断点就非常有用了。<br><img src="/.com//24.gif" alt="Alt text"></p><h3 id="25-临时断点"><a href="#25-临时断点" class="headerlink" title="25.  临时断点"></a>25.  临时断点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mouse : 在左侧框上`alt + 单击`</span><br><span class="line">Mac : cmd + alt + shift + f8 </span><br><span class="line">Windows / Linux : ctrl + alt + shift + f8</span><br></pre></td></tr></table></figure><p>添加一个断点， 第一次运行触发到它后自动移除该断点。<br><img src="/.com//25.gif" alt="Alt text"></p><h3 id="26-禁用断点"><a href="#26-禁用断点" class="headerlink" title="26.  禁用断点"></a>26.  禁用断点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mouse : 在左侧框上的已存在的断点上 `alt + 单击` </span><br><span class="line">这个没有键盘快捷键，如果你经常用到它的话可以自己创建一个</span><br></pre></td></tr></table></figure><p>这将禁用该断点。当你有一些复杂的条件或日志断点，你现在不需要但你不想下次重新创建的时候可以禁用断点。</p><blockquote><p><strong>译者注：</strong> Eclipse 中该操作快捷键是 在左侧框上 <code>shift + 双击</code> .</p></blockquote><p><img src="/.com//26.gif" alt="Alt text"></p><h3 id="27-附加到调试器"><a href="#27-附加到调试器" class="headerlink" title="27.  附加到调试器"></a>27.  附加到调试器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mouse: 点击这个图标或从菜单选择`Build-&gt;Attach to Android Process`（译者注：不知道此菜单是否为MAC上的功能，Windows下的为`Run-&gt;Attach debugger to Android Process`） </span><br><span class="line">这个没有键盘快捷键，但你应该创建一个。</span><br></pre></td></tr></table></figure><p>当你没有以调试模式启动应用时可以通过该方法调试应用。这个是非常有用的， 因为你不用重新以调试模式部署应用。当有人在测试应用时，测出一个bug, 给你他的设备时，这个操作就相当有用。<br><img src="/.com//27.gif" alt="Alt text"></p><h3 id="28-表达式求值"><a href="#28-表达式求值" class="headerlink" title="28.  表达式求值"></a>28.  表达式求值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mouse: 点击这个图标或从菜单选择`Build-&gt;Attach to Android Process`（译者注：不知道此菜单是否为MAC上的功能，Windows下的为`Run-&gt;Attach debugger to Android Process`） </span><br><span class="line">这个没有键盘快捷键，但你应该创建一个。</span><br></pre></td></tr></table></figure><p>它被用来检查一个变量的内容以及对任何有效的java表达式求值。需要知道的是如果你的状态改变了，当你恢复程序的执行时候它还会保持那种结果。</p><blockquote><p><strong>译者注：</strong> Eclipse 中在断点处选中变量、表达式然后 <code>右键 -&gt; watch</code>查看表达式的值</p></blockquote><p><img src="/.com//28.gif" alt="Alt text"></p><h3 id="29-查看值"><a href="#29-查看值" class="headerlink" title="29.  查看值"></a>29.  查看值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mouse: 在表达式上` alt + 单击`</span><br></pre></td></tr></table></figure><p>查看一个表达式的值不会打开<code>Evaluate</code>表达式对话框。</p><blockquote><p><strong>译者注：</strong> Eclipse 中该操作的快捷键是<code>ctrl + shift + i</code>, 或者使用鼠标<code>右键 -&gt; Inspect</code></p></blockquote><p><img src="/.com//29.gif" alt="Alt text"></p><h3 id="30-标记对象"><a href="#30-标记对象" class="headerlink" title="30.  标记对象"></a>30.  标记对象</h3><p>在<code>variables</code>或<code>watch</code>面板上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mouse: `右击`选择 `Mark Object`</span><br><span class="line">Mac : 选中对象后 + `f3`</span><br><span class="line">Windows / Linux : 选中对象后 + `f11`</span><br></pre></td></tr></table></figure><p>在调试会话中，这个可以在一个指定的对象上添加一个标签，因此稍后你可以识别它。在你有一些相似的对象并且你想知道它和之前的是同一个对象时这样的调试会话中是非常有用的。<br><img src="/.com//30.gif" alt="Alt text"></p><h3 id="31-异常栈分析"><a href="#31-异常栈分析" class="headerlink" title="31.  异常栈分析"></a>31.  异常栈分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">菜单: `Analyze -&gt; Analyze Stacktrace`</span><br><span class="line">查找action: `analyze stacktrace`</span><br></pre></td></tr></table></figure><p>该操作可以抓取已经显示在<code>logcat</code>中的异常栈并使之可以点击跳转到相关代码。当从<code>bug</code>日志或终端复制异常堆栈时非常有用。<br><img src="/.com//31.gif" alt="Alt text"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Android Studio&lt;/code&gt;中快捷键使用技巧三–调试时可能会使用到的快捷键&lt;/p&gt;</summary>
    
    
    
    <category term="android" scheme="https://www.likebamboo.com/categories/android/"/>
    
    
    <category term="androidstuido" scheme="https://www.likebamboo.com/tags/androidstuido/"/>
    
  </entry>
  
  <entry>
    <title>【译】Android Studio 使用技巧系列(二)-快捷键</title>
    <link href="https://www.likebamboo.com/2015/09/29/android-studio-tips-2/"/>
    <id>https://www.likebamboo.com/2015/09/29/android-studio-tips-2/</id>
    <published>2015-09-29T06:00:00.000Z</published>
    <updated>2025-10-29T12:10:40.715Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><blockquote><p>原文:<a href="http://www.developerphil.com/android-studio-tips-of-the-day-roundup-2/">http://www.developerphil.com/android-studio-tips-of-the-day-roundup-2/</a></p></blockquote><p>接上篇：</p><h3 id="11-复制行"><a href="#11-复制行" class="headerlink" title="11.  复制行"></a>11.  复制行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + d</span><br><span class="line">Windows / Linux : ctrl + d</span><br></pre></td></tr></table></figure><p>正如字面意思：它将会复制当前行并且粘贴在下一行，它并不会复制到剪贴板。当它被用于复制当前行时它将会是非常有用的。（ 译者注： 当然，该命令也可以复制选中的行）。</p><blockquote><p>**译者注：**Eclipse 中该操作的快捷键是 <code>ctrl + alt + up/down</code></p></blockquote><p><img src="/.com//11.gif" alt="Alt text"></p><h3 id="12-扩大-收缩-选中部分"><a href="#12-扩大-收缩-选中部分" class="headerlink" title="12.  扩大&#x2F;收缩 选中部分"></a>12.  扩大&#x2F;收缩 选中部分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : alt + up/down </span><br><span class="line">Windows / Linux : ctrl + w / ctrl + shift + w</span><br></pre></td></tr></table></figure><p>这个能扩大当前选中的区域。如它能选择当前的变量，然后是声明，然后是方法等等。<br><img src="/.com//12.gif" alt="Alt text"></p><h3 id="13-包裹代码块"><a href="#13-包裹代码块" class="headerlink" title="13. 包裹代码块"></a>13. 包裹代码块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + alt + t</span><br><span class="line">Windows / Linux : ctrl + alt + t</span><br></pre></td></tr></table></figure><p>该快捷键被用来用一些结构包裹代码块。通常使用<code>if</code>、<code>while</code>、<code>try-catch</code>或<code>runnable</code>。<br>如果什么也没有选中，它将会包裹当前行。<br><img src="/.com//13.gif" alt="Alt text"></p><h3 id="14-最近打开的文件"><a href="#14-最近打开的文件" class="headerlink" title="14. 最近打开的文件"></a>14. 最近打开的文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + e</span><br><span class="line">Windows / Linux : ctrl + e</span><br></pre></td></tr></table></figure><p>在第一篇文章中已经提到，使用这个可以得到一个最近打开的文件的可搜索的列表！<br><img src="/.com//14.gif" alt="Alt text"></p><h3 id="15-在线模版"><a href="#15-在线模版" class="headerlink" title="15. 在线模版"></a>15. 在线模版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + j</span><br><span class="line">Windows / Linux : ctrl + j</span><br></pre></td></tr></table></figure><p>在线模板是一个快速插入代码片段的方式。使用在线模板有趣的是它能参数化，当你插入代码时它可以使用参数智能的引导你。<br><img src="/.com//15.gif" alt="Alt text"><br><strong>相关技巧</strong></p><blockquote><ul><li>如果你知道它的缩写你就不需要调用快捷键。你可以直接输入它并用<code>Tab</code>键完成输入。</li></ul></blockquote><h3 id="16-移动方法"><a href="#16-移动方法" class="headerlink" title="16. 移动方法"></a>16. 移动方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + alt + up/down</span><br><span class="line">Windows / Linux : ctrl + shift + up/down</span><br></pre></td></tr></table></figure><p>这个和移动当前行类似，但它可以用于整个方法。它可以上下移动一个方法不用复制粘贴。<br>这个<code>action</code>真正的名称是<code>Move Statement</code>。这意味着它可以移动<code>statement</code>中的任何一种。如：你可以重新排列字段和内部类的顺序。<br><img src="/.com//16.gif" alt="Alt text"></p><h3 id="17-语句补全"><a href="#17-语句补全" class="headerlink" title="17.  语句补全"></a>17.  语句补全</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + shift + enter</span><br><span class="line">Windows / Linux : ctrl + shift + enter</span><br></pre></td></tr></table></figure><p>它可以在编写语句时生成未完成的代码，通常用于下列情况：</p><ul><li>在行尾添加一个分号，甚至可以在你的光标没在行尾时</li><li>在<code>if</code>、<code>while</code>或<code>for</code>添加括号和花括号</li><li>在方法的声明后添加一个花括号</li></ul><p><img src="/.com//17.gif" alt="Alt text"></p><p><strong>相关技巧</strong></p><blockquote><ul><li>如果<code>statement</code>已经完成，它会直接跳到下一行，即使光标没有在当前行的最后一个字符。</li></ul></blockquote><h3 id="18-上次编辑位置"><a href="#18-上次编辑位置" class="headerlink" title="18.   上次编辑位置"></a>18.   上次编辑位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + shift + backspace</span><br><span class="line">Windows / Linux : ctrl + shift + backspace</span><br></pre></td></tr></table></figure><p>在第一篇文章中已经提到,它将会跳到你最后修改代码的位置。这个和工具栏上的后退是不同的，它会在你的编辑历史中跳转，而不是导航历史.<br><img src="/.com//17-navigate-previous-changes.gif" alt="Alt text"></p><h3 id="19-代码合并"><a href="#19-代码合并" class="headerlink" title="19.  代码合并"></a>19.  代码合并</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : ctrl + shift + j</span><br><span class="line">Windows / Linux : ctrl + shift + j</span><br></pre></td></tr></table></figure><p>这个比在行尾模拟删除键能做的更多！它会保存格式化规则，还有下面的特性：</p><ul><li>合并两个注释行并且删除没有用的 <code>//</code></li><li>合并多行字符串，移除加号和双引号</li><li>合并字段和赋值</li></ul><p><strong>相关技巧</strong></p><blockquote><ul><li>如果你选择一个多行的字符串，它将会合并成一行。</li></ul></blockquote><p><img src="/.com//18-joinlines.gif" alt="Alt text"></p><h3 id="20-选择于"><a href="#20-选择于" class="headerlink" title="20.  选择于"></a>20.  选择于</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : alt + f1</span><br><span class="line">Windows / Linux : alt + f1</span><br></pre></td></tr></table></figure><p>询问你从哪选择当前的文件。恕我直言，这是最有用的快捷键对于在工程结构中或你的文件资源管理器中打开。每个<code>action</code>都有一个字母或数字的前缀，这是快速调用它的快捷键。<br>通常，我会使用<code>Alt+F1</code>然后回车为了在工程视图中打开和<code>Alt+F1+8</code>在<code>Mac</code>的文件资源管理器中打开。<br>你可以从工程视图中调用这个对于一个文件或文件夹。<br><img src="/.com//19.gif" alt="Alt text"></p><h3 id="21-移除包裹代码"><a href="#21-移除包裹代码" class="headerlink" title="21.  移除包裹代码"></a>21.  移除包裹代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + shift + delete</span><br><span class="line">Windows / Linux : ctrl + shift + delete</span><br></pre></td></tr></table></figure><p>移除周围代码。它可以移除<code>if</code>、<code>while</code>、<code>try/catch</code>甚至一个<code>runnable</code>。这个正好和<code>Surround With</code>（包裹代码块）的快捷键功能相反。<br><img src="/.com//20.gif" alt="Alt text"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Android Studio&lt;/code&gt;中快捷键使用技巧二&lt;/p&gt;</summary>
    
    
    
    <category term="android" scheme="https://www.likebamboo.com/categories/android/"/>
    
    
    <category term="androidstuido" scheme="https://www.likebamboo.com/tags/androidstuido/"/>
    
  </entry>
  
  <entry>
    <title>【译】Android Studio 使用技巧系列(一)-快捷键</title>
    <link href="https://www.likebamboo.com/2015/09/29/android-studio-tips-1/"/>
    <id>https://www.likebamboo.com/2015/09/29/android-studio-tips-1/</id>
    <published>2015-09-29T05:00:00.000Z</published>
    <updated>2025-10-29T12:10:40.712Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><blockquote><p>原文:<a href="http://www.developerphil.com/android-studio-tips-of-the-day-roundup-1/">http://www.developerphil.com/android-studio-tips-of-the-day-roundup-1/</a></p></blockquote><h3 id="1-高亮所有相同变量"><a href="#1-高亮所有相同变量" class="headerlink" title="1. 高亮所有相同变量"></a>1. 高亮所有相同变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + shift + f7</span><br><span class="line">Windows / Linux : ctrl + shift + f7</span><br></pre></td></tr></table></figure><p>这个快捷键将会高亮当前选中字符所有的出现之处。当然这个快捷键不仅仅只是一些简单地模式匹配，它还会理解当前的变量所处范围，只高亮相关的字符。<br>高亮之后你就可以使用<code>Edit → Find → Find Next/Previous</code>处定义的快捷方式来选择你要操作的高亮字符。</p><blockquote><p><strong>译者注：</strong> Eclipse 中高亮显示成员变量的快捷键是 <code>alt + shift + o</code> .</p></blockquote><p><strong>相关技巧：</strong></p><blockquote><ul><li>高亮代码方法中的<code>return</code> 或者 <code>throw</code>, 同时也会高亮这个方法的所有出口。</li><li>高亮<code>Java</code>类的<code>extends</code> 或者<code>implements</code> 的定义部分也会高亮对应的重写或者实现的方法。</li><li>高亮<code>import</code>语句也会高亮它被使用的地方。</li><li><code>Esc</code>键可以取消高亮。</li></ul></blockquote><p><img src="/.com//1.gif" alt="Alt text"></p><h3 id="2-在方法和内部类之间跳转"><a href="#2-在方法和内部类之间跳转" class="headerlink" title="2. 在方法和内部类之间跳转"></a>2. 在方法和内部类之间跳转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : ctrl + up/down</span><br><span class="line">Windows / Linux : alt + up/down</span><br></pre></td></tr></table></figure><p>这个快捷键可以让你很方便的在当前文件的方法或者类上面跳转。<br>如果你当前处于一个方法中，此快捷键（向上）可以让你的光标跳至方法名处。这对你重构代码或者找到这个代码的使用之处很有帮助。</p><blockquote><p><strong>译者注：</strong> Eclipse 中该快捷键是 <code>ctrl + shift + up/down</code> .</p></blockquote><p><img src="/.com//2.gif" alt="Alt text"></p><h3 id="3-类文件结构弹窗"><a href="#3-类文件结构弹窗" class="headerlink" title="3. 类文件结构弹窗"></a>3. 类文件结构弹窗</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + f12</span><br><span class="line">Windows / Linux : ctrl + f12</span><br></pre></td></tr></table></figure><p>这个快捷键可以帮助你展示当前类文件的方法结构。你可以使用这个快捷键弹出弹窗，查找你想要的方法名。</p><blockquote><p><strong>译者注：</strong> Eclipse 中该快捷键是 <code>ctrl + o</code> .</p></blockquote><p><strong>相关技巧：</strong></p><blockquote><ul><li>你可以使用驼峰字符来过滤候选方法列表。例如:输入<code>oCr</code> 就可以找到<code>onCreate</code>方法。</li><li>你可以选择是否展示匿名类。如果你勾选了<code>是</code>就可以很方便的查找<code>OnClickListener</code>里面的<code>onClick</code>方法了。</li></ul></blockquote><p><img src="/.com//3.gif" alt="Alt text"></p><h3 id="4-方法调用层级弹窗"><a href="#4-方法调用层级弹窗" class="headerlink" title="4. 方法调用层级弹窗"></a>4. 方法调用层级弹窗</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : ctrl + alt + h</span><br><span class="line">Windows / Linux : ctrl + alt + h</span><br></pre></td></tr></table></figure><p>这个快捷键会显示一个方法的声明和它的调用之间的可能的路径。<br><img src="/.com//4.gif" alt="Alt text"></p><h3 id="5-快速查找定义"><a href="#5-快速查找定义" class="headerlink" title="5. 快速查找定义"></a>5. 快速查找定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : alt + space </span><br><span class="line">Windows / Linux : ctrl + shift + i</span><br></pre></td></tr></table></figure><p>你是否曾经想在当前页面查看一个方法或类的定义？使用这个快捷键在当前页面查找它。<br><img src="/.com//05-quickdefinition.gif" alt="Alt text"></p><h3 id="6-折叠或展开代码块"><a href="#6-折叠或展开代码块" class="headerlink" title="6.  折叠或展开代码块"></a>6.  折叠或展开代码块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : alt + plus/minus </span><br><span class="line">Windows / Linux : ctrl + shift + plus/minus</span><br></pre></td></tr></table></figure><p>这个特性的目的是隐藏在某一时刻你不关心的代码。在这个简单的形式中，它将会隐藏整个代码块（如：当你打开一个新文件时忽略导入列表）。更有趣的是它可以隐藏匿名内部类周围的模板代码让它看起来像是一个<code>lambda</code>表达式。<br><img src="/.com//6.gif" alt="Alt text"></p><p><strong>相关技巧：</strong></p><blockquote><ul><li>你可以在<code>Setting-&gt;Editor-&gt;Code Folding</code>中设置默认的折叠范围</li></ul></blockquote><h3 id="7-书签"><a href="#7-书签" class="headerlink" title="7.   书签"></a>7.   书签</h3><h4 id="7-1-设置或取消书签"><a href="#7-1-设置或取消书签" class="headerlink" title="7.1 设置或取消书签"></a>7.1 设置或取消书签</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : f3</span><br><span class="line">Windows / Linux : f11</span><br></pre></td></tr></table></figure><h4 id="7-2-带助记符的书签"><a href="#7-2-带助记符的书签" class="headerlink" title="7.2  带助记符的书签"></a>7.2  带助记符的书签</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : alt + f3</span><br><span class="line">Windows / Linux : alt + f11</span><br></pre></td></tr></table></figure><p>如你给书签分配了一个数字，你可以使用下面的快捷键返回到对应书签： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+number</span><br></pre></td></tr></table></figure><h4 id="7-3-显示书签列表"><a href="#7-3-显示书签列表" class="headerlink" title="7.3  显示书签列表"></a>7.3  显示书签列表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + f3</span><br><span class="line">Windows / Linux : shift + f11</span><br></pre></td></tr></table></figure><p><img src="/.com//7.gif" alt="Alt text"></p><blockquote><p><strong>译者注：</strong> Eclipse  中貌似并没有书签的快捷键，但是同样也可以设置书签，只要在编辑窗口左边的边框上右键就可以看到添加书签的菜单。 同时可以通过<code>window -&gt; show view -&gt; Bookmarks</code>来查看所有书签。</p></blockquote><h3 id="8-查找菜单项"><a href="#8-查找菜单项" class="headerlink" title="8. 查找菜单项"></a>8. 查找菜单项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + shift + a</span><br><span class="line">Windows / Linux :  ctrl + shift + a</span><br></pre></td></tr></table></figure><p>你可以通过名称在Android Studio中调用任何你知道的菜单或<code>action</code>！对于你之前使用过但没有快捷键的命令来说这是非常有用的。<br><img src="/.com//8.gif" alt="Alt text"></p><p><strong>相关技巧：</strong></p><blockquote><ul><li>如果这个Action有快捷键，它将会显示在旁边。</li></ul></blockquote><h3 id="9-移动行"><a href="#9-移动行" class="headerlink" title="9.  移动行"></a>9.  移动行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : alt + shift + up/down</span><br><span class="line">Windows / Linux :  alt + shift + up/down</span><br></pre></td></tr></table></figure><p>对，这个是用来上下移动当前或选择行代码。没有什么更多要说的，享受它吧。</p><blockquote><p><strong>译者注：</strong> Eclipse  中的快捷键是: <code>alt + up/down</code></p></blockquote><p><img src="/.com//9.gif" alt="Alt text"></p><h3 id="10-删除行"><a href="#10-删除行" class="headerlink" title="10.  删除行"></a>10.  删除行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + backspace</span><br><span class="line">Windows / Linux :  ctrl + y</span><br></pre></td></tr></table></figure><p>这个是用来删除当前或选中的行代码</p><blockquote><p><strong>译者注：</strong> Eclipse  中的快捷键是: <code>ctrl + d</code></p></blockquote><p><img src="/.com//10.gif" alt="Alt text"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Android Studio&lt;/code&gt;中快捷键使用技巧&lt;/p&gt;</summary>
    
    
    
    <category term="android" scheme="https://www.likebamboo.com/categories/android/"/>
    
    
    <category term="androidstuido" scheme="https://www.likebamboo.com/tags/androidstuido/"/>
    
  </entry>
  
  <entry>
    <title>【译】Android Studio 使用技巧系列-快捷键跳转</title>
    <link href="https://www.likebamboo.com/2015/09/29/android-studio-tips-0/"/>
    <id>https://www.likebamboo.com/2015/09/29/android-studio-tips-0/</id>
    <published>2015-09-29T04:00:00.000Z</published>
    <updated>2025-10-29T12:10:40.711Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><blockquote><p>原文: <a href="http://www.developerphil.com/android-studio-tips-tricks-moving-around/">http://www.developerphil.com/android-studio-tips-tricks-moving-around/</a></p></blockquote><p>你应该知道的关于我的两件事： </p><ol><li>我是一个 IDE 狂热者 </li><li>我是一个高效极客</li></ol><p>两年前，当我转向<code>Intellij IDEA</code>，<code>Android Studio</code>基于它，为了更高效的开发，我花费了大量的时间去寻找快捷键以及使用技巧。当你看到这篇文章，我相信你也做了很多同样的事情，所以我努力让它更容易而且更方便一些。</p><p>在这个系列教程中，我们将学习到每个开发者都应该知道的最基本的开发技巧以及<code>Android Studio</code>中更多高级的技能。</p><h3 id="关于键位映射"><a href="#关于键位映射" class="headerlink" title="关于键位映射"></a>关于键位映射</h3><p><code>Android Studio</code> 提供了不同的键位映射（即快捷键和它对应的操作之间的映射），你可以在 <code>Settings-&gt;Keymap</code> 菜单里面查看当前所使用的键位映射。<br>单纯列出每个键位映射是不切实际的，因此将会使用下面的：</p><blockquote><p>Windows: 默认<br>Linux: 默认<br>OSX: Mac OSX 10.5+(不是默认的一个，强烈建议使用Jetbrains)</p></blockquote><h3 id="来回跳转"><a href="#来回跳转" class="headerlink" title="来回跳转"></a>来回跳转</h3><p>我们花费了大量的时间在代码跳转上，让我们尝试提高它的效率。</p><h3 id="1-打开类-文件-标记"><a href="#1-打开类-文件-标记" class="headerlink" title="1. 打开类&#x2F; 文件&#x2F; 标记"></a>1. 打开类&#x2F; 文件&#x2F; 标记</h3><h4 id="1-1-打开类"><a href="#1-1-打开类" class="headerlink" title="1.1 打开类"></a>1.1 打开类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac :  cmd + o</span><br><span class="line">Windows / Linux : ctrl + n</span><br></pre></td></tr></table></figure><p>假设你要切换到名为<code>MainActivity.java</code>的类，就可以使用该快捷键然后输入<code>Main</code>就可以了。</p><blockquote><p> <strong>译者注：</strong>  Eclipse 中打开类的快捷键是 <code>ctrl + shift + t</code></p></blockquote><h4 id="1-2-打开文件"><a href="#1-2-打开文件" class="headerlink" title="1.2 打开文件"></a>1.2 打开文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac :  cmd + shift + o</span><br><span class="line">Windows / Linux : ctrl + shift + n</span><br></pre></td></tr></table></figure><p>和打开类相似，但是该快捷键可以打开工程目录下的任意文件。这可以快速帮你打开如<code>AndroidManifest.xml</code>或<code>res</code>和<code>assets</code>目录下的文件</p><blockquote><p> <strong>译者注：</strong>  Eclipse 中打开任意文件的快捷键是 <code>ctrl + shift + r</code></p></blockquote><h4 id="1-3-打开标记"><a href="#1-3-打开标记" class="headerlink" title="1.3 打开标记"></a>1.3 打开标记</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac :  cmd + alt + o</span><br><span class="line">Windows / Linux : alt + shift + n</span><br></pre></td></tr></table></figure><p>功能强大但没有前面的两个快捷键出名：你可以通过搜索方法或变量名称直接跳转。<br>例如，你知道工程中的某个地方有个名为<code>getFormattedDate()</code>的方法，你可以使用这个快捷键直接找到它。</p><p><strong>技巧：</strong></p><blockquote><p><strong>部分匹配：</strong> 如果你有一个类叫<code>ItemDetailFragment</code>，你可以在搜索的时候直接输入<code>IDF</code>就可以查找到的<br><strong>行号：</strong> 假设你有一个同事刚刚告诉你<code>XXX</code>在<code>ExcitingClass</code>的第<code>23</code>行，可以在打开类快捷键上中加上<code>ExcitingClass:23</code>或者<code>EC:23</code>可以快速跳转到指定行号</p></blockquote><h3 id="2-最近使用文件"><a href="#2-最近使用文件" class="headerlink" title="2. 最近使用文件"></a>2. 最近使用文件</h3><h4 id="2-1-最近打开文件"><a href="#2-1-最近打开文件" class="headerlink" title="2.1 最近打开文件"></a>2.1 最近打开文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac :  cmd + e</span><br><span class="line">Windows / Linux : ctrl + e</span><br></pre></td></tr></table></figure><p>该快捷键将弹出一个最近打开文件的对话框</p><h4 id="2-2-最近打开文件"><a href="#2-2-最近打开文件" class="headerlink" title="2.2 最近打开文件"></a>2.2 最近打开文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac :  cmd + shift + e </span><br><span class="line">Windows / Linux : ctrl + shift + e </span><br></pre></td></tr></table></figure><p>和上面功能类似，但列出的仅仅是被修改过的文件。</p><blockquote><p> <strong>译者注：</strong>  Eclipse 中貌似没有列出最近使用的文件的功能， <code>ctrl + e</code> 快捷键用于列表当前编辑窗口中打开的文件。</p></blockquote><p><strong>技巧：</strong></p><blockquote><p> 输入字符可以进行列表过滤</p></blockquote><h3 id="3-前进或后退"><a href="#3-前进或后退" class="headerlink" title="3.  前进或后退"></a>3.  前进或后退</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac :  cmd + alt + left/right</span><br><span class="line">Windows / Linux : ctrl + alt + left/right</span><br></pre></td></tr></table></figure><p>想要更好地理解这个快捷键，你应该想想<code>web</code>浏览器上前进和后退是怎样工作的。现在不是在<code>web</code>页面上，而是源代码中！因此当你跳转到一行代码或打开一个新的文件时，IDE将会记住你之前的位置，并且可以快速返回。</p><blockquote><p> <strong>译者注：</strong>  Eclipse 中前进或后退的快捷键是  <code>alt + left/right</code> .</p></blockquote><h3 id="4-最近编辑位置"><a href="#4-最近编辑位置" class="headerlink" title="4.   最近编辑位置"></a>4.   最近编辑位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac :  cmd + shift + backspace </span><br><span class="line">Windows / Linux : ctrl + shift + backspace</span><br></pre></td></tr></table></figure><p>这个是上面的快捷键一个衍生，它可以在上次修改代码位置之间进行跳转。<br>想像你正在修改一个让人讨厌的bug。你觉得你可以解决它并且开始修复它，但当你意识到在你的工程中你不得不去看<code>android</code>源代码和其它类的时候，你进入其它类的一个功能，然后又跳到其它文件中20步以后，你终于完成了你的修复，但你刚才正在编辑的是哪一行？只要使用这个快捷键你就可以正确地返回。</p><h3 id="5-显示引用"><a href="#5-显示引用" class="headerlink" title="5. 显示引用"></a>5. 显示引用</h3><h4 id="5-1-在固定面板上-Android-Studio-左下方，译者注-显示引用"><a href="#5-1-在固定面板上-Android-Studio-左下方，译者注-显示引用" class="headerlink" title="5.1 在固定面板上(Android Studio  左下方，译者注)显示引用"></a>5.1 在固定面板上(Android Studio  左下方，译者注)显示引用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac :  alt + f7</span><br><span class="line">Windows / Linux : alt + f7</span><br></pre></td></tr></table></figure><p>该快捷键可以显示被引用地方。对于一个类变量来说，会显示变量使用和赋值的地方。对于一个类方法来说，会显示方法被调用的地方。对于一个类来说，会显示创建实例的地方。<br>你可以使用箭头键和返回键在显示结果中查看。然后可以使用<code>Esc</code>返回到编辑窗口。</p><blockquote><p> <strong>译者注：</strong>  Eclipse 中显示引用的快捷键是  <code>ctrl + shift + g</code> .</p></blockquote><h4 id="5-2-在弹窗上显示引用"><a href="#5-2-在弹窗上显示引用" class="headerlink" title="5.2 在弹窗上显示引用"></a>5.2 在弹窗上显示引用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac :  cmd + alt + f7</span><br><span class="line">Windows / Linux : ctrl + alt + f7</span><br></pre></td></tr></table></figure><p>和上面作用一样，显示在弹出框中。</p><h3 id="6-跳转到声明-实现-快速滚动"><a href="#6-跳转到声明-实现-快速滚动" class="headerlink" title="6. 跳转到声明&#x2F;实现(快速滚动)"></a>6. 跳转到声明&#x2F;实现(快速滚动)</h3><p>这里有三个关于符号的快捷键</p><h4 id="6-1-跳转到声明"><a href="#6-1-跳转到声明" class="headerlink" title="6.1 跳转到声明"></a>6.1 跳转到声明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + b  或者 cmd + click</span><br><span class="line">Windows / Linux : ctrl + b  或者 ctrl + click</span><br></pre></td></tr></table></figure><p>跳到类、方法或变量声明的地方。跳到类和方法的实现上是很有用的.</p><blockquote><p> <strong>译者注：</strong>  Eclipse 中跳转到声明的快捷键是  <code>f3</code> 或者 <code>ctrl + click</code> .</p></blockquote><h4 id="6-2-跳转到实现"><a href="#6-2-跳转到实现" class="headerlink" title="6.2 跳转到实现"></a>6.2 跳转到实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + alt + b</span><br><span class="line">Windows / Linux : ctrl + alt + b</span><br></pre></td></tr></table></figure><p>显示所有类&#x2F;接口的实现类&#x2F;接口。对于方法也适用，会显示重写的方法。对于变量，会跳转到声明</p><h4 id="6-3-跳转到类型声明"><a href="#6-3-跳转到类型声明" class="headerlink" title="6.3 跳转到类型声明"></a>6.3 跳转到类型声明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + shift + b</span><br><span class="line">Windows / Linux : ctrl + shift + b</span><br></pre></td></tr></table></figure><p>当光标在一个变量上，它会跳到变量类型的声明处。例如，下面一行代码： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Developer phil = new Developer(&quot;Phil&quot;); </span><br></pre></td></tr></table></figure><p>如果光标在<code>phil</code>变量上，按下快捷键会跳到<code>Developer</code>类的声明处。</p><h3 id="7-跳转到父类"><a href="#7-跳转到父类" class="headerlink" title="7.  跳转到父类"></a>7.  跳转到父类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac : cmd + u</span><br><span class="line">Windows / Linux : ctrl + u</span><br></pre></td></tr></table></figure><p>这个快捷键会打开当前选中的父类，和跳转到实现的功能想相反。如果光标在一个重写的方法是，将会直接跳转的父类的方法。如果光标在一个类中但在方法之外或光标在类名上，那么它会打开父类。<br>快速跳转到类、变量或者方法的声明。主要用在类和方法</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在这个系列教程中，我们将学习到每个开发者都应该知道的最基本的开发技巧以及&lt;code&gt;Android Studio&lt;/code&gt;中更多高级的技能。&lt;/p&gt;</summary>
    
    
    
    <category term="android" scheme="https://www.likebamboo.com/categories/android/"/>
    
    
    <category term="androidstuido" scheme="https://www.likebamboo.com/tags/androidstuido/"/>
    
  </entry>
  
  <entry>
    <title>图片选择控件</title>
    <link href="https://www.likebamboo.com/2014/04/28/image-choser-library/"/>
    <id>https://www.likebamboo.com/2014/04/28/image-choser-library/</id>
    <published>2014-04-27T16:00:00.000Z</published>
    <updated>2025-10-29T12:10:40.744Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司有一个项目需要支持手机本地图片的多选,就像微信那样的。<br>OK,不能调用系统的图片选择控件,那就自己写个吧,基本思路就是使用ContentProvider扫描手机中的图片,然后以Gridview的方式展示图片。</p><span id="more"></span><p>同时为了保证能图片能快速加载,需要对图片进行缓存(内存缓存是必须的,由于本来就是本地的图片,暂时可以不用再在SD卡中缓存)。<br>ContentProvider扫描手机中的图片好办,关键是如何更快的加载图片。  </p><h2 id="Universal-Image-Loader"><a href="#Universal-Image-Loader" class="headerlink" title="Universal Image Loader ?"></a>Universal Image Loader ?</h2><p>最初想到的就是使用开源图片加载框架 <a href="https://github.com/nostra13/Android-Universal-Image-Loader">UIL</a>  , 作为目前使用最广泛的图片加载框架,不用真是可惜了,于是优先考虑它了。<br>Demo很快就写好了,大部分手机上也测试OK,但是在一台小米3手机上出现了内存溢出的问题,如下图(OOM导致了部分图片出现加载失败):<br><img src="/.com//image_chooser_1.png" alt="图片"></p><p>究其原因,米三手机的分辨率(1920*1080)太大,拍照拍出来的图片也大(一般都在2M左右),当一次加载的图片太多的时候就容易出现内存溢出的情况。<br>为了不占用太多的内存,我按照官方的说法(见UIL项目介绍)：  </p><ol><li>将内存缓存的图片尺寸改小(之前没有指定,UIL框架默认会按照手机的分辨率来确定缓存图片的尺寸)：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ImageLoaderConfiguration.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageLoaderConfiguration</span>.Builder(context)</span><br><span class="line">    ...</span><br><span class="line">    .memoryCacheExtraOptions(<span class="number">480</span>, <span class="number">800</span>) <span class="comment">// default = device screen dimensions</span></span><br><span class="line">    .discCacheExtraOptions(<span class="number">480</span>, <span class="number">800</span>, CompressFormat.JPEG, <span class="number">75</span>, <span class="literal">null</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ol start="2"><li>将显示时的图片的质量降低、同时图片缩放：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DisplayImageOptions</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisplayImageOptions</span>.Builder()</span><br><span class="line">    ...</span><br><span class="line">    .bitmapConfig(Bitmap.Config.RGB_565)</span><br><span class="line">    .imageScaleType(ImageScaleType.EXACTLY)</span><br><span class="line">    ...</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>OK,内存溢出的现象是不见了,但是新的问题出现了:<br>由于UIL的缓存配置是全局的,如果设置缓存的图片尺寸较小,那么当用户需要查看大图片的时候,可能加载出来的图片是小尺寸的缓存图片。<br>况且像这样指定缓存图片的大小可能影响到其他使用的UIL显示大图界面,所以为了不影响UIL在其他界面的使用,还是不要限制图片在内存中缓存的尺寸。<br>另外UIL在缓存图片的时候虽然也有控制图片缩放的参数<code>.imageScaleType</code>但是却不能根据需要来缩放,所以种种原因迫使我放弃使用UIL来加载本地图片。  </p><h2 id="普通多线程"><a href="#普通多线程" class="headerlink" title="普通多线程 ?"></a>普通多线程 ?</h2><p>在决定放弃使用UIL加载本地图片之后，我开始自己写缓存图片的方案，我的想法是只在内存中缓存就好，没必要再在本地磁盘中缓存一份，同时为了保存不OOM，需要限定缓存图片的规格。<br>于是我专门写了一个加载本地图片的类，使用android支持包中的LruCache作为内存缓存，根据要显示图片的ImageView控件的宽和高来缩放图片以降低内存使用量。<br>使用时也比较简单:  </p><ol><li>当要加载图片的时候首先查找内存LruCache中是否有缓存，如果有直接返回该缓存图片。  </li><li>如果内存中没有缓存，创建一个新线程用于加载图片。加载图片之前首先根据传入的图片的宽高参数计算目标图片的缩放比，之后根据缩放比从磁盘中取出相应的图片并返回，同时将图片缓存到内存LruCache以便下次使用。</li></ol><p>由于使用LruCache，出现内存不足的时候，系统会自动gc，所以一般情况不会出现OOM的情况。同时由于没有缓存的时候都会新建一个线程用于加载图片所以加载图片的速度也还可以接受。<br>但是问题是，当图片多的时候，频繁新建线程的内存开销会比较大，这样会导致UI线程卡慢的情况(ListView或GridView滚动不流畅)。<br>出现这种情况后我立马就想可以，用线程池来代替每次都新建线程的情况。  </p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池 ?"></a>线程池 ?</h2><p>用线程池代替Thread比较简单，Java中的Executors类以工厂模式的方式提供了一些快速创建常用的线程池的方法。例如:  </p><ol><li>创建固定大小的线程池: <code>Executors.newFixedThreadPool(int nThreads);</code>  </li><li>创建大小为1的固定线程池: <code>Executors.newSingleThreadExecutor();</code>  </li><li>创建线程keepAliveTime为1分钟的可伸缩线程池: <code>Executors.newCachedThreadPool();</code>  </li><li>创建一个支持定时及周期性的任务执行的线程池: <code>Executors.newScheduledThreadPool(int nThreads);</code></li></ol><p>使用线程池后UI主线程不卡了，但又有问题，当图片多的时候，Gridview滑动到底部，这时候图片可能要等很久才能加载出来。这种情况很好理解，当图片很多的时候，线程池中的那几个线程根本不够用，所以这时候图片的加载还是会表现出一定的顺序性。如果直接滑动到GridView或ListView的底部，图片自然要等一段时间才能加载出来。<br>于是乎我想，可以通过监听ListView&#x2F;GridView的滚动来控制图片是否加载，当控件滚动的时候不加载图片，只有当其静止的时候才加载。</p><h2 id="监听ListView-GridView的滚动事件"><a href="#监听ListView-GridView的滚动事件" class="headerlink" title="监听ListView&#x2F;GridView的滚动事件 ?"></a>监听ListView&#x2F;GridView的滚动事件 ?</h2><p>最初想到这种方式后并没有立即就去做，原因就是这种方式的可复用性比较低，要所有显示本地图片的界面都去监听滚动事件有点不切实际，况且从没见过哪个图片加载框架要监听控件的滚动，但他们都运行的好好的，所以这种方法肯定不是最好的。<br>更现实的问题是当某次要加载的图片特别多的时候（比如说超过1000张），如果用户恰好要选择靠后的图片，这时候控件大部分时间处于滚动的状态，如果此时不加载图片，就会给用户一个图片没有加载的信号，用户感官上会觉得图片加载很慢。同时在滑动的过程中，从用户手指离开屏幕到控件完全停止滚动是一个减速的过程，这个过程有一段时间，如果在这段时间就开始加载图片而不是等到控件完全停止才加载，那么等控件停止的时候就可以省下不少加载图片的时间了。<br>综合考虑以上因素，我放弃了通过监听ListView&#x2F;GridView 的滚动事假来判断是否应该加载图片的这种想法。  </p><h2 id="我的最终方案-YES"><a href="#我的最终方案-YES" class="headerlink" title="我的最终方案 YES"></a>我的最终方案 YES</h2><p>重新审视这个问题，我觉得至少有两个条件必须满足：  </p><ol><li>尽可能少占用内存,不OOM是底线(线程池+内存LruCache基本可以达到这个要求)。  </li><li>图片加载的速度要快。</li></ol><p>第二个问题是目前最棘手的问题。如果优先加载ListView&#x2F;GridView可见区域的图片而暂时忽略不可见部分的图片，由于可见部分的图片数量比较少，即使单个图片比较大也能在短时间内将可见区域的图片加载完。这样不管用户想要看前面的图片还是后面的图片都能在短时间内在界面上显示，这样用户的体验会比较好。<br>前面讲到的监听控件的滚动事件其实际也是优先加载可见区域的图片。那么可不可以用其他方法优先加载可视化区域的图片呢？<br>经过一段时间的探索，我的最终方案确定了:<br>由于在ListView&#x2F;GridView滚动的时候会调用其adapter的getView方法(该方法中发送加载图的请求)，而且是只有当ListView或GridView中的Item可见的时候才会调用getView方法，<br>这样我们就可以人为定义图片加载的优先级了，总结起来一句话:后来居上。 具体实施方案如下： </p><ol><li>自己维护一个请求列表，根据请求的不同优先级加载图片，具体是这样的。  </li><li>首先判断图片是否在内存缓存中，如果有，直接从内存中取出图片。  </li><li>如果没有，构建一个图片请求对象，加入到请求列表(如果请求列表中原来有这个请求，删除原来的，将新的加入到列表末尾，这样可以保证该请求的优先级高)  </li><li>线程池按照如下的规则处理图片请求列表:</li></ol><ul><li>如果请求列表中的请求数量小于线程池中空闲的线程数，顺序的将请求分配给线程池中空闲线程(这时候请求列表中的所有请求同时得到执行)  </li><li>如果请求列表中的请求数量大于线程池中空闲的线程数，将空闲的线程的分配给优先级高的请求(优先级根据请求的先后顺序来定，后请求的优先级高)</li></ul><ol><li>当某个请求被执行完后，从请求列表中删除请求任务，同时，如果请求列表中还有未处理完的任务，继续按照上述规则处理请求。</li></ol><p>这样最终效果还不错，也达到了我与其的效果。<br><img src="/.com//snapshot.png" alt="图片"></p><blockquote><p>查看源代码<a href="https://github.com/likebamboo/ImageChooser">https://github.com/likebamboo/ImageChooser</a>。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近公司有一个项目需要支持手机本地图片的多选,就像微信那样的。&lt;br&gt;OK,不能调用系统的图片选择控件,那就自己写个吧,基本思路就是使用ContentProvider扫描手机中的图片,然后以Gridview的方式展示图片。&lt;/p&gt;</summary>
    
    
    
    <category term="android" scheme="https://www.likebamboo.com/categories/android/"/>
    
    
    <category term="控件" scheme="https://www.likebamboo.com/tags/%E6%8E%A7%E4%BB%B6/"/>
    
    <category term="图片" scheme="https://www.likebamboo.com/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
</feed>
